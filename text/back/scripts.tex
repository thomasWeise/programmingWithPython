\hsection{Scripts}%
%
\gitBash{\programmingWithPythonCodeRepo}{scripts/mypy.sh}{bash:mypy}{%
A \bash\ script for executing \mypy, which prints the command line and the exit code; see \cref{ut:mypy}.}%
%
\gitBash{\programmingWithPythonCodeRepo}{scripts/ruff.sh}{bash:ruff}{%
A \bash\ script for executing \ruff, which prints the command line and the exit code; see \cref{ut:ruff}.}%
%
\gitBash{\programmingWithPythonCodeRepo}{scripts/pylint.sh}{bash:pylint}{%
A \bash\ script for executing \pylint, which prints the command line and the exit code; see \cref{ut:pylint}.}%
%
Here we provide some scripts that are used within this book.
These scripts are written for the \bash\ shell, which is the default interpreter running in \ubuntu\ \linux\ \pglspl{terminal}.
Therefore, they will not work under \windows\ or other operating systems.
Now, our book focuses on \python\ programming, so \bash\ shell scripts are not in the center of our attention.
We here cannot explain how \bash\ scripts work or what their syntax is.
There exist plenty of books and resources on this interesting topic, such as~\cite{NR2005LTBSUSPCB3,Z2017MB,BN2018BC} or \url{https://www.gnu.org/software/bash/}.
If we would include the scripts in the places where we use them in this book, then this would lead to confusion or tangents in the text which would mess up the flow of the chapters.
Nevertheless, the book would be incomplete if these scripts were not provided at all.
So we put them here, at the end of the book, where they do not hurt anyone and where the interested reader may check them out.%

\Cref{lst:bash:mypy} is a \bash\ script which first checks whether \mypy\ is installed.
If \mypy\ is not installed, it silently installs it.
The script then composes the command for applying \mypy\ to the target file(s) in the target directory.
It then prints the command with a prepended~\expandafter\textil{\$}.
Then, it executes it.
\mypy\ will print its comments and messages to the standard output.
Finally, the script shows the \mypy\ version and exit code in a brief success or failure message (with a prepended~\expandafter\textil{\#}).
\Cref{exec:variables:variable_types_wrong_hints_1:mypy,exec:variables:variable_types_wrong_hints_2:mypy} are example outputs of this script.

\Cref{lst:bash:ruff} works basically the same way, just for \ruff.
However, it sets a lot more parameters to \ruff.
See, \ruff\ offers many more configuration options and many more different things that it can check for, compared to \mypy.
In it's present form, it does not check for type errors, as far as I know, though.
Either way, it is harder to balance the strictness of the tool and there are even some rules which are sometimes mutually exclusive.
Hence, we compose a more complex command.
Apart from that, this script works pretty much the same as \cref{lst:bash:mypy}.
\Cref{exec:lists:lists_error:ruff,exec:lists:lists_fixed:ruff} are examples for the output of this script.

\Cref{lst:bash:pylint} offers exactly the same functionality for \pylint.
It checks if this tool is installed and installs it if not.
It then applies \pylint\ to a the selected set of files, using a reasonable default configuration.
\Cref{exec:loops:for_loop_no_enumerate:pylint} is an example for the output of this \pgls{linter}.%
%
\endhsection%
%
