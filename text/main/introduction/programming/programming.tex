\hsection{Why Programming \emph{and} Software Engineering Tools?}%
A big part of our life consists of performing tasks, chores, and other work.
Often, we do not enjoy performing chores and tasks and other work.
Naturally, we want to delegate them.
We want someone else to do them.
In order to make this possible, we need to explain to that other person what we want them to do.

If you are a chef in a kitchen, you have to tell the junior trainee chef:
\inQuotes{First you wash the potatoes, then peel the potato skin, then you wash the potatoes again, and then you cook them.}
If you are visiting the hairdresser to get your hair done, you would say something like:
\inQuotes{Wash my hair, then cut it down to 1cm on the top, trim the sides, then color it green.}

In either cases, you provided the other person with a clear and unambiguous sequence of instructions in a language they can understand.
In this book, you will learn to do the same --- with computers.
%
\begin{definition}[Computer Program]%
A \emph{computer program} is an unambiguous sequence of computational instructions for a computer to achieve a specific goal.%
\end{definition}%
\begin{definition}[Programming]%
\label{def:programming}
\emph{Programming} is the activity or job of writing computer programs~\cite{CDE2024PMOPIE}.%
\end{definition}%
%
Now, in the vast majority of situations, we do not create a program to just use it one single time.
Actually, this is similar to the real life situation of work delegation again:
If you were a chef, you basically \inQuotes{input} the \inQuotes{program} \emph{cook potatoes} into the junior trainee once.
In the future, you would like to be able go to them and invoke this program again by saying:
\inQuotes{Please cook 2kg of potatoes}.

Indeed, your \inQuotes{programs} often even have implicit parameters, like the quantity of~2kg mentioned above.
Or, maybe, you go to the hairdresser again and want to say: \inQuotes{Same as usual, but today color it blue.}
In our day-to-day interactions, creating reusable and parameterized programs happens very often and very implicitly.
We usually do not think about this in any explicit terms.

But if we write programs for computers, we \emph{do} need to think about it in explicit terms and right from the start.
The activity of pure programming listed in \cref{def:programming} is only one part of software development.
Imagine the following scenario:

In this book we discuss how to translate some kind of specification into \python\ code.
Let's say that later in your job, you want to develop a program that can be used to solve a specific task.
So, well, you write the program.
You learned how to do that with this book.
So you now have the file with the program code.
The problem is solved.

Is that easy?
On one hand, you may wonder whether you made any mistake.
We are people, we all make mistakes.
The more complex the task we tackle, the more (program code) we write, the more likely it is that we make some small error somewhere.
So probably you want to \emph{test} your program, i.e., check if it really computes the things that it should compute it the way you intended it to compute these things.

And what if your program is not just a single-use, stand-alone kind of program?
What if it is part of some sort of software ecosystem?
What if other programs may later need to use/run it?
Maybe it can access some sort of sensor measuring something, or maybe it can convert data from one file format to another one.
Then, other programmers may need to be able to at least understand how to correctly run the program and what kind of input and output data it will expect or produce, respectively.

What if this program is going to be needed for the next ten or so years?
Maybe it could eventually become necessary to add new functionality?
Maybe some of the software libraries you use get outdated and need to be replaced?
There also are several situations in which a totally different person may need to work, read, modify, and improve \emph{your} code.

Or maybe you are a researcher, using \python~3 to implement some algorithm and to run an experiment.
In order to make your experiments and results replicable, you would probably want to publish your algorithm implementation together with the results.
This only makes sense if your code is at least a bit readable.

All of these things need to be considered when we learn how to program.
Because you do not just \inQuotes{program,} you develop software.

In typical courses, such aspects are ignored.
In a typical course, you learn how to write a small program that solves a certain task.
The task is usually simple, so the teachers are able to read your code even if you have ugliest style imaginable.
Also, nobody is ever going to look at or use the programs you write as your homework again.
In such a pristine scenario, none of the above really matters.
But in reality, things are not always simple.

One may hope that, as one of the very first things, surgery students in medical school are taught to wash their hands before performing surgery.
And you, our dear students, can expect us to teach you how to develop software properly.
And we will try to do that.
We will teach you how to write clean, well-documented, and properly tested programs.
Right from the start.
Such that all of your code will be reusable, readable, clear, clean, and \emph{beautiful}.

As a result, this will be a course which is very practice centered.
We will learn programming the \emph{right} way.%
\endhsection%
%
