\hsection{Exceptions}%
\label{sec:exceptions}%
%
So far, we have mainly focused on writing correct code.
We try to create code that is free of errors.

When we execute our programs, then there are at least two things that can go wrong.
On one hand, we can never really be sure that our program code is free of programming mistakes.
The larger a project gets, the more likely it is that there are some bugs hidden somewhere in the code.
Thorough \pglspl{unitTest} can reduce the likelihood of bugs, but it cannot entirely prevent them.

On the other hand, our programs do not exist all by themselves in a vacuum.
They receive input, maybe from files, maybe from the user, maybe from sensors.
This input may be wrong.

Coarsely, we can group both kinds of problems together as situations that were not anticipated, that are exceptions from the intended program flow.
We already have encountered such situations.
For example, trying to access a character of a string at an index greater than or equal to the length of the string will lead to an~\pythonilIdx{IndexError}, as we saw in \cref{sec:strBasicOperations}.
The attempt to modify an element of a \pythonil{tuple} is punished with a \pythonilIdx{TypeError} in \cref{sec:tuples}.
Back in \cref{sec:float:special}, we saw that trying to compute something like \pythonil{(10 ** 400) * 1.0} will yield an \pythonilIdx{OverflowError}, as the integer~$10^{400}$ is too large to be converted to a \pythonil{float} during the multiplication with~\pythonil{1.0}.

Clearly, some of these errors may result from programming mistakes.
But they could just as well result from invalid data being entered in the input of the program.%
%
\hsection{Introduction}%
When we create a new function or program, we have to face the question:
\emph{What should we do if we receive incorrect input?}
We can imagine three different approaches:%
%
\begin{enumerate}%
%
\item We simply ignore the issue.
If the input of our program or function is faulty, then the output will be wrong, too.
This is often called \pgls{GIGO}~\cite{PKBCBR2005GIGOAELAOMBEUP}.
Converting the integer \pythonil{10 ** 400} to a \pythonil{float} could just yield~\pythonil{inf}, for example.%
%
\item We try to sanitize the input.
For example, our \pythonil{factorial} function in \cref{lst:functions:def_factorial} expects an integer as input.
If someone were to pass in the floating point value~\pythonil{2.4} instead, we could round it to~\pythonil{2} and return the result.
Matter of fact, our \pythonil{sqrt} function implemented in \cref{lst:functions:my_math_2} returns \pythonil{0.0} if we pass in a negative number.%
%
\item We can guard the function by raising an \pythonilIdx{Exception}~\cite{MAGTOC2024EHFAP,SF2013ASROSR,GRRX2001ACSOEHMFBDOOS}.%
%
\end{enumerate}%
%
The latter is what \python\ does in the examples mentioned initially:
While it could simply ignore if we try to overwrite an element of a \pythonil{tuple}, it instead raises an~\pythonilIdx{TypeError}, for example.
Personally, I am also a fan of this approach.

If we would follow the \pgls{GIGO} paradigm, then faulty data will propagate.
Maybe the output of our function is fed as input into another function, whose output is then piped into another function, and so on.
An error could then will lead to some crash down the line.
If functions that are written under the assumption that \pgls{GIGO} is OK are paired with such that perform input sanitization, errors could remain unnoticed.
The erroneous results could then become part of some actual, real-life decisions and designs.
And even if found out, it will be extremely hard to discover where things went wrong in the long chain of computations and function calls.

Input sanitization could cover some error that happened earlier.
This could even cause more errors, because it will allow other programmers to call our code with wrong values.
Input sanitization encourages sloppy programming.

This leaves raising an \pythonilIdx{Exception}.
But what does that actually mean?
Raising an \pythonilIdx{Exception} means two things:%
%
\begin{enumerate}%
%
\item We store information about the error and information about the current execution state (current line of code and the function call hierarchy) in an object (the \pythonilIdx{Exception}).%
%
\item The control flow immediately leaves the currently executed block of instructions as well as all calling blocks or functions.
It jumps up in the call hierarchy until reaching code that handles the raised exception.
If no such code exists, the current process is terminated with an \pgls{exitCode} different from~\textil{0}.%
%
\end{enumerate}%
%
In other words, raising an exception is a way to exit the current control flow and to signal an error that must either explicitly be handled by code or will lead the process to terminate.
In my opinion, this is the best way to handle incorrect input or other erroneous situations for several reasons:%
%
\begin{enumerate}%
%
\item It clearly and explicitly shows that an error has happened, \emph{where} it happened, \emph{when} it happened, and, to some degree, \emph{why} it happened.
This makes it much easier to find out whether the error is caused by invalid input or by a programming mistake.%
%
\item It prevents \pgls{GIGO} from occurring.
Thus, it prevents a faulty situation or corrupted data from propagating out of the current context.
If an error occurs, this the raised exception takes down the current path of execution and this stops the contaminated control flow.%
%
\item It forces programmers to explicitly deal with the error condition.
An error cannot be simply ignored.
Indeed, someone who calls our code might write code that ignores or discards the \pythonilsIdx{Exception} that we raised.
But they have to do so \emph{explicitly} in their code.
Thus, they have to \emph{intentionally} deal with the possible error condition.
It cannot happen that an error gets overlooked.
An exception that is not handled will lead to the termination of the process.%
%
\item One might argue: \inQuotes{But what if the process crashes because an exception is not handled?}
The answer may be:
What is worse?
That an error causes the current process to crash unexpectedly or that all future results after the error are wrong and, even worse, are wrong \emph{unnoticed}?%
%
\end{enumerate}%
%
\bestPractice{exceptions}{%
Errors should \emph{not} be ignored and input data should \emph{not} be artificially sanitized. %
Instead, the input of functions should be checked for validity wherever reasonable. %
Faulty input should always be signaled by errors breaking the program flow. %
\pythonilsIdx{Exception} should be raised as early as possible and whenever an unexpected situation occurs.%
}%
%
\endhsection%
%
\hsection{Raising Exceptions}%
%
\gitPython{\programmingWithPythonCodeRepo}{exceptions/sqrt_raise.py}{--args format}{exceptions:sqrt_raise}{%
A new variant of the \pythonil{sqrt} function from back in \cref{lst:functions:my_math_2} that raises an \pythonilIdx{ArithmeticError} if its input is non-finite or negative.}%
%
\gitPythonAndErrorOutput{\programmingWithPythonCodeRepo}{exceptions}{use_sqrt_raise.py}{--args format}{exceptions:use_sqrt_raise}{%
Using the new variant of the \pythonil{sqrt} function from \cref{lst:exceptions:sqrt_raise} that raises an \pythonilIdx{ArithmeticError} if its input is non-finite or negative.}%
%
Let us now first look at an example of how we can signal an error condition in our code.
For this purpose, we re-visit the square root function that \pythonil{sqrt} we implemented back in \cref{lst:functions:my_math_2} in \cref{sec:unitTesting}.
In that implementation, we realized that certain input values such as \pythonil{inf}, \pythonil{-inf}, \pythonil{nan}, and \pythonil{0.0} deserve special treatment.
We also found that nothing could stop a user to pass a negative number as input to our \pythonil{sqrt} implementation.
We did not yet have any means to deal with nonsense in a reasonable way, so we decided to just return~\pythonil{0.0} in that case.

Obviously, this is a bad idea because passing a negative number to \pythonil{sqrt} can only mean two things:
Either the programmer who did that does not know that a square root is.
Or the negative input came as the result from another computation and that computation somehow was wrong.
In the first case, we should somehow make it explicit to the programmer that the square root of a negative number is not defined and that they should question their approach to mathematics.
In the second case, we should rather stop the computation right there and then before the incorrect results propagate and do some damage elsewhere.
In both cases, returning~\pythonil{0.0} is not a good idea.

Instead, we want to signal this error explicitly.
Our function should raise an exception.
We therefore create a new implementation of \pythonil{sqrt} in \cref{lst:exceptions:sqrt_raise}.
Before writing the actual \python\ code, we will express the new behavior in the \pgls{docstring} of our function:%
%
\bestPractice{exceptionDoc}{%
\sloppy%
Any function that may raise an exception should explain any exception that it explicitly raises in the \pgls{docstring}. %
This is done by writing something like \textil{:raises ExceptionType: why} where \textil{ExceptionType} is to be replaced with the type of the exception raised and \textil{why} with a brief explanation why it will be raised.%
}%
\fussy%
%
In our case, any input~$x$ for which~$\sqrt{x}$ would be either undefined or not finite should lead to an error.
Since this error is of arithmetic nature, we will raise an~\pythonilIdx{ArithmeticError}.
Our \pgls{docstring} therefore contains the line \textil{:raises ArithmeticError: if `number` is not finite or less than `0.0`}.
Any other programmer using our code therefore can easily see what kind of \pythonilsIdx{Exception} our code could raise.

In the new \pythonil{sqrt} implementation \cref{lst:exceptions:sqrt_raise} we first check whether either \pythonil{not isfinite(number)}\pythonIdx{isfinite} or \pythonil{number < 0.0} holds.
The \pythonilIdx{isfinite} function is offered by the \pythonilIdx{math} module and returns \pythonil{True} if its argument is either \pythonilIdx{inf}, \pythonilIdx{-inf}, or~\pythonilIdx{nan}.
The complete expression becomes \pythonil{True} if the input of the function is not finite or negative.
We thus check whether the output of the \pythonil{sqrt} function would not be a finite number.
If this is indeed the case, we \pythonil{raise ArithmeticError(f"sqrt(\{number\}) is not permitted.")}.

\pythonilIdx{raise} is the keyword used to, well, raise an exception, i.e., to signal an error.
\pythonilIdx{ArithmeticError} then creates the object with the information about the exception.
We can pass a string as parameter to this function, and we here chose to pass in an \pgls{fstring} which contains the value of the number with which our \pythonil{sqrt} function was called.
This line of code will force the control flow to immediately exit our \pythonil{sqrt} function.
The \pythonilIdx{Exception} object \inQuotes{raises} up until it is either caught (which we discuss later) or the process itself is terminated.

The latter can be observed in \cref{lst:exceptions:use_sqrt_raise}.
In the program, we iteratively apply our new \pythonil{sqrt} function to the values inside a \pythonil{tuple} using a \pythonilIdx{for}~loop.
We write the results of these computations to the \pgls{stdout} using \pgls{fstring} and \pythonil{print}.\footnote{%
The \pythonil{flush=True} parameter passed to \pythonilIdx{print}\pythonIdx{print!flush} forces the output to be immediately written and not cached. %
This is only useful to keep the output in order in this example, because the \pgls{stdout} and \pgls{stderr} are captured and presented in \cref{exec:exceptions:use_sqrt_raise} and the order of the text could otherwise get mixed up.%
}
The first five numbers are fine and \pythonil{sqrt} returns the proper results.
However, the latter three numbers, \pythonilIdx{inf}, \pythonilIdx{nan}, and \pythonil{-1.0} all would cause an error.

We collect the output of the program in \cref{exec:exceptions:use_sqrt_raise}.
As can be seen, for \pythonil{0.0}, \pythonil{1.0}, \pythonil{2.0}, \pythonil{4.0}, and \pythonil{10.0}, the results are printed as anticipated.
However, when the \pythonilIdx{for}~loop reaches \pythonilIdx{inf}, the program is terminated an the so-called \pgls{stackTrace} is written to the output.

It begins with the line \textil{Traceback (most recent call last):}.
In the first line following this text, the source code file and the index of the line in that file where the exception was originally raised are printed.
Notice that the actual path to the files will be different depending on where the source code of the examples is located.
We replaced the variable part of the path with~\inQuotes{\{\dots\}}.
The remaining part of the path, \textil{exceptions/use_sqrt_raise.py}, clearly points out the calling program as the culprit \cref{lst:exceptions:use_sqrt_raise}.
We already took a glimps on how useful the \pgls{stackTrace} is back in \cref{sec:errorsInIde}.
Indeed, the following line of text identifies that instruction in \cref{lst:exceptions:use_sqrt_raise} that caused the error and even marks the offending function invocation by underlining it with \textil{{^}{^}{^}{^}{^}{^}{^}{^}{^}{^}{^}{^}}.
Below that, we get to see the context of our \pythonil{sqrt} function:
First, the path to its module is given (ending in \textil{exceptions/sqrt_raise.py}) and it is pointed out that the exception was raised in line~15.
This line of code is then also given, and it indeed is the one starting with \pythonil{raise ArithmeticError}.
The \pgls{stackTrace} therefore shows us exactly where the error happened and from where the code causing the error was called.%
%
\begin{sloppypar}%
After the \pgls{stackTrace}, we can see information about the error printed that we passed in:
\textil{ArithmeticError: sqrt(inf) is not permitted.}
We made this message by ourselves using an \pgls{fstring} when raising the exception.
We did this so that it tells the user that \pythonil{sqrt} was called with the argument \pythonil{inf} that we did not permit.%
\end{sloppypar}%
%
The above information allows us to pretty much identify the source of the problem.
It shall be stated here that new programmers often ignore the \pgls{stackTrace}.
They see that a program produces and error and then try to figure out why by looking at their code.
They often do not read the \pgls{stackTrace} or the error information below it.%
%
\bestPractice{exceptionStackTrace}{%
The \pgls{stackTrace} and error information printed on the \python\ console in case of an uncaught exception are essential information to identify the problem. %
They should \emph{always} be read and understood before trying to improve the code. %
See also \cref{bp:readErrorMessage}.%
}%
%
In our original \pythonil{tuple} of inputs that we iteratively passed to \pythonil{sqrt}, the last three elements are \pythonilIdx{inf}, \pythonilIdx{nan}, and \pythonil{-1.0}.
The call to \pythonil{sqrt} with \pythonil{inf} as argument was performed and failed.
After that, no further output has been generated.
Indeed, the control flow has left the \pythonil{for}~loop and the process has been terminated with \pgls{exitCode}~1, as the output in \cref{exec:exceptions:use_sqrt_raise} shows.

Terminating the process may seem rash, but it is not.
If a programmer used our \pythonil{sqrt} function incorrectly, then this will force them to fix their error.
If the input \pythonil{inf} was the result of corrupted data, another erroneous computation, or an input mistake by the user, then terminating the program prevented this error from propagating.
For both scenarios, the \pgls{stackTrace} and error output gives clear information about what went wrong and where.%
%
\FloatBarrier%
\endhsection%
%
\hsection{Handling Exceptions}%
%
Of course, we do not want that all possible unexpected error conditions will immediately terminate our process.
For example, maybe we programmed a program for painting a picture, the user painted a picture and wants to store it, but enters a wrong destination.
It would be annoying if the program would immediately crash.
In this section, we discuss how errors can be handled.
We use examples that are specifically constructed to cause certain errors to illustrate how we can deal with them.%
%
\hsection{The \texttt{try}\dots\texttt{except} Block}%
%
The \pythonilIdx{try}\nobreakdashes-\pythonilIdx{except} clause exists as primary approach to recover from errors.
We place the code that may raise an exception into an indented block that is prefixed by \pythonil{try:}.
After this block, we write the handlers for specific exception types.
For example, if we assume that a block could raise an \pythonilIdx{ArithmeticError}, we could write \pythonil{except ArithmeticError as ae:}\pythonIdx{as}.
The code inside this \pythonilIdx{except} block would be executed if and only if indeed an \pythonilIdx{ArithmeticError} was raised somewhere in the \pythonilIdx{try} block.
In this case, the \pythonilIdx{ArithmeticError} would be available as local variable \pythonil{ae} in this block.
Of course, multiple different types of \pythonilsIdx{Exception} may be raised, so we can have multiple \pythonilIdx{except} blocks.
This looks like this:%
%
\begin{pythonSyntax}
try:  # Begin the try-except block.
    # Code that may raise an exception or that
    # calls a function that may rise one.
except ExceptionType1 as ex1:  # One exception type that can be caught.
    # Code the handles exceptions of type ExceptionType1.
except ExceptionType2 as ex2:  # Another exception type (optional).
    # Code the handles exceptions of type ExceptionType2 that are not
    # instances of ExceptionType1.

next statement  # Executed only if there are no uncaught Exceptions.
\end{pythonSyntax}
\FloatBarrier%
%
\gitPythonAndOutput{\programmingWithPythonCodeRepo}{exceptions}{try_except_str_index.py}{--args format}{exceptions:try_except_str_index}{%
The \pythonil{index}\pythonIdx{str!index} function of a string raises a \pythonilIdx{ValueError} if it cannot find the given substring. %
Here we catch this error in a \pythonilIdx{try}\idxdots\pythonilIdx{except} block.}%
%
Let us now try the \pythonil{try}-\pythonil{except} block.
Back in \cref{sec:strBasicOperations}, we learned that text strings offer the method \pythonil{r.find(s)}\pythonIdx{str!find}\pythonIdx{find} that searches a string~\pythonil{s} inside~\pythonil{r} and returns the first index where it is encountered.
If \pythonil{s} cannot be found in~\pythonil{r}, \pythonil{-1}~is returned instead.
There exists a very simply operation \pythonil{r.index(s)}\pythonIdx{str!index}\pythonIdx{index}, which works exactly like \pythonilIdx{find}, but instead of returning~\pythonil{-1}, it will raise a \pythonilIdx{ValueError} if \pythonil{s} cannot be found in~\pythonil{r}.
This is quite useful in cases where we know that \pythonil{s} must be contained in \pythonil{r} and if it is not, then that is an error.

In \cref{lst:exceptions:try_except_str_index}, we explore this behavior.
Our string~\pythonil{r} is \pythonil{"Hello World!"}.
In the \pythonilIdx{try}-block, we place a \pythonil{for} loop which lets a variable~\pythonil{s} iteratively take on three values.
In its first iteration, \pythonil{s = "Hello"} and \pythonil{r.index(s)} will yield~\pythonil{0}.
This is printed to the output.
In the second iteration, \pythonil{s = "world"}, which cannot be found since searching in strings is case-sensitive.
\pythonil{r.index(s)} will therefore raise an exception.

The \pythonilIdx{except} block after the \pythonil{try} block is executed if anywhere inside the \pythonil{try} block a \pythonilIdx{ValueError} is raised.
In this case, this \pythonilIdx{ValueError} becomes available in variable~\pythonil{ve}.
In this block, we simply print the error.

After the block, we print \pythonil{"The program is now finished."}.
This code is executed only if no uncaught exception has left the \pythonil{try}-\pythonil{except} block.
The output of the program given in \cref{exec:exceptions:try_except_str_index} shows that this is indeed the case:
We first get the results of the successful search for \pythonil{"Hello"}, followed by the output for the failed search.
The last line then is \textil{The program is now finished.}

Notice that the third value in the loop, \pythonil{"!"}, never gets assigned to the variable \pythonil{s}.
The \pythonilIdx{try} block is immediately terminated as soon as any exception occurs.
If the exception can be handled by a corresponding \pythonilIdx{except} block, then this block is executed.
Otherwise, the whole process will be terminated.
Either way, even if a fitting \pythonilIdx{except} block exists, the code after the failing instruction in the \pythonilIdx{try} block will not be executed.

While we can catch and handle \pythonilsIdx{Exceptions}, it is important to only handle reasonable errors.
For example, suppose your program should be writing text to a file.
It is totally acceptable that this may fail for a variety of file system related reasons, like insufficient space on the device, an access rights violation, or an incorrect file name.
Such errors may be handled with a corresponding \pythonilIdx{except} block and reasonable actions may be taken.
If, on the other hand, a \pythonilIdx{ZeroDivisionError} would occur during our attempt to write the file, then this indicates that something else went really wrong.
Such an error is not OK in this context.
So we should only try to catch errors that are meaningful and that we anticipate in a given context.
Any other error should indeed cause our program to crash, to prevent more problems later.
A crashed program is the clearest indicator to the user that something is wrong and that actions on their side are required, after all.%
%
\bestPractice{onlyCatchMeaningfulExceptions}{%
Only \pythonilsIdx{Exception} should be caught by \pythonilIdx{except} blocks that we can meaningfully handle. %
The \pythonilIdx{except} block is not to be used to just catch any exception, to implement \gls{GIGO}, or to try to sanitize erroneous input.%
}%
%
\gitPythonAndErrorOutput{\programmingWithPythonCodeRepo}{exceptions}{try_multi_except.py}{--args format}{exceptions:try_multi_except}{%
The handling of multiple errors, namely \pythonilIdx{ZeroDivisionError} and \pythonilIdx{ArithmeticError}, as well as what happens if a variable remains unassigned due to an error (a \pythonilIdx{NameError} is raised).}%
%
In \cref{lst:exceptions:try_multi_except}, we revisit our new \pythonil{sqrt} function.
This function will \pythonilIdx{raise} an \pythonilIdx{ArithmeticError} if its argument is non-finite or negative.
This time, we want to compute~$\sqrt{\frac{1}{0}}$ and thus aim to store the result of \pythonil{sqrt(1 / 0)} in a variable \pythonil{sqrt_of_1_div_0}.
We first declare the variable as a \pythonil{float}.
Then, in a \pythonilIdx{try}-\pythonilIdx{except} block, we perform the actual computation: \pythonil{sqrt_of_1_div_0 = sqrt(1 / 0)}.
Knowing that \pythonil{sqrt} might raise an \pythonilIdx{ArithmeticError}, we provide a corresponding \pythonilIdx{except} block.
However, we also know that \pythonil{1 / 0} looks a bit dodgy, as we also try to intercept a potential \pythonilIdx{ZeroDivisionError} error.
As you can see, we can have two independent \pythonilIdx{except} clauses.

So, which one will be executed?
Certainly, $\frac{1}{0}$ is not finite, so \pythonil{sqrt} will raise an exception.
Then again, $\frac{1}{0}$ cannot be computed at all, so maybe we get a \pythonilIdx{ZeroDivisionError} error instead?
We find that the \pythonilIdx{except} block for \pythonilIdx{ZeroDivisionError} is executed.
The reason is that in order to invoke \pythonil{sqrt(1 / 0)}, the \python\ interpreter must first compute the result of~\pythonil{1 / 0}.
This computation raises \pythonilIdx{ZeroDivisionError} and \pythonil{sqrt} is never called.

This leads us to the question:
If \pythonil{sqrt} is never called, then what will be assigned to \pythonil{sqrt_of_1_div_0}?
The answer is: Nothing.
In order to perform the assignment, we would need the result of \pythonil{sqrt(1 / 0)}.
But since this result never becomes available, the assignment is never performed.

This means that when we try to \pythonil{print(sqrt_of_1_div_0)} after the \pythonilIdx{try}-\pythonilIdx{except} block, the value of \pythonil{sqrt_of_1_div_0} is undefined.
The variable \pythonil{sqrt_of_1_div_0} never really received any value at all.
Trying to access it will \pythonilIdx{raise} a \pythonilIdx{NameError}.
While we did declare it, the \python\ interpreter does not know this variable yet, as it does not have a value.
Our program will terminate, because the \pythonilIdx{NameError} is never caught anywhere.
Instead, the \pgls{stackTrace} and error information will be printed in \cref{exec:exceptions:try_multi_except}.%
%
\bestPractice{noAssignAfterRaise}{%
If an exception is raised, be aware that the control flow will immediately leave the current block. %
The statement in which the exception was raised will not be completed but aborted right away. %
Therefore, no variable assignments or other side-effects can take place anymore and it is possible that variables remain undefined.%
}%
%
\FloatBarrier%
\endhsection%
%
\hsection{Exceptions in Exception Handlers}%
%
\gitPythonAndErrorOutput{\programmingWithPythonCodeRepo}{exceptions}{try_except_nested_1.py}{--args format}{exceptions:try_except_nested_1}{%
An example of \pythonils{Exception} being raised inside an \pythonilIdx{except} block.}%
%
What happens if an exception is raised \emph{inside} an \pythonilIdx{except} block?
In \cref{lst:exceptions:try_except_nested_1}, we try to compute \pythonil{sqrt_of_1_div_0 = sqrt(1 / 0)} twice.
First in the \pythonilIdx{try} block, exactly as in \cref{lst:exceptions:try_multi_except} and then again in the \pythonilIdx{except} block that handles the \pythonilIdx{ZeroDivisionError} that this will cause.
So inside an \pythonilIdx{except} block for handling \pythonilsIdx{ZeroDivisionError}, another \pythonilIdx{ZeroDivisionError} will be raised.

The result is shown in \cref{exec:exceptions:try_except_nested_1}:
The \pythonilIdx{except} block is terminated immediately and text is written to the \gls{stderr} indicating why.
While we handled the original \pythonilIdx{ZeroDivisionError}, another error occurred.
The output first presents the \pgls{stackTrace} of the exception that we were handling.
It then informs us that \textil{During handling of the above exception, another exception occurred:}.
Then it prints the \pgls{stackTrace} of the new exception that occurred inside the \pythonilIdx{except} block.
Since there is no code for handling this error, our process terminates with \pgls{exitCode}~1.

\gitPythonAndOutput{\programmingWithPythonCodeRepo}{exceptions}{try_except_nested_2.py}{--args format}{exceptions:try_except_nested_2}{%
An example of nested \pythonilIdx{try}-\pythonilIdx{except} blocks, as an improvement over \cref{lst:exceptions:try_except_nested_1}.}%
%
It is of course possible that an error that we normally can handle may cause another error.
Therefore, like any other \python\ code blocks, we can also nest \pythonilIdx{try}-\pythonilIdx{except} blocks.
\Cref{lst:exceptions:try_except_nested_2} shows exactly this.
By placing the second \pythonil{sqrt} invocation located in the \pythonilIdx{except} block into yet another \pythonilIdx{try}-\pythonilIdx{except} block, we can catch the \pythonilIdx{ZeroDivisionError} error.%
%
\FloatBarrier%
\endhsection%
%
\hsection{The \texttt{try}\dots\texttt{except}\dots\texttt{else} Block}%
%
What can we do if we need the result of a computation inside a \pythonilIdx{try} block but only can use it if the \pythonilIdx{try} block completely succeeds?
One possible solution in such a situation is the \pythonilIdx{try}-\pythonilIdx{except}-\pythonilIdx{else} block.
The difference to the \pythonilIdx{try}-\pythonilIdx{except} block is only that an \pythonilIdx{else} block follows, which is executed if and only if no exception occurred.%
%
\begin{pythonSyntax}
try:  # Begin the try-except block.
    # Code that may raise an exception or that
    # calls a function that may rise one.
except ExceptionType1 as ex1:  # One exception type that can be caught.
    # Code the handles exceptions of type ExceptionType1.
# ... maybe more `except` blocks
else:
    # Code executed if and only if no Exception occurred.

next statement  # Executed only if there are no uncaught Exceptions.
\end{pythonSyntax}
%
\gitPythonAndOutput{\programmingWithPythonCodeRepo}{exceptions}{try_except_else.py}{--args format}{exceptions:try_except_else}{%
An example of the \pythonilIdx{try}-\pythonilIdx{except}-\pythonilIdx{else} block which is structured a bit similar to \cref{lst:exceptions:try_multi_except} but avoids the \pythonilIdx{NameError} by placing the access to the variables into the \pythonilIdx{else} blocks.}%
%
In \cref{lst:exceptions:try_except_else}, we present an example of the \pythonilIdx{try}-\pythonilIdx{except}-\pythonilIdx{else} block.
The example is structured a bit similar to \cref{lst:exceptions:try_multi_except}.
We again use our own \pythonil{sqrt} function, this time attempting to compute~$\sqrt{\frac{1}{0}}$ and then~$\sqrt{3}$, each within its own block.
Back in \cref{lst:exceptions:try_multi_except}, we got a \pythonilIdx{NameError} because we wanted to access the value of a variable that we assigned in the \pythonilIdx{try} block.
The \pythonilIdx{try} block failed.
While we did catch and process the \pythonilIdx{ZeroDivisionError} in an \pythonilIdx{except} block, the variable was never assigned.
So accessing the variable later cause the error.

This time, we place the code for accessing the variables into \pythonilIdx{else} blocks.
These blocks are \emph{only} executed if the \pythonilIdx{try} block succeeds.
Hence, the variables are guaranteed to be exist and have values properly assigned to them if the \pythonilIdx{else} blocks are reached.
In case of~$\sqrt{\frac{1}{0}}$, the \pythonilIdx{else} block is not reached.
In case of~$\sqrt{3}$, it is and its corresponding \pythonil{print} instruction is executed.
\Cref{lst:exceptions:try_except_else} shows that this program can properly finish.%
%
\endhsection%
%
\hsection{The \texttt{try}\dots\texttt{finally} Block}%
\label{sec:tryFinally}%
%
We do know that errors may occur in a piece of code.
These may be errors that we can reasonably expect to potentially happen.
Such errors we will process with corresponding \pythonilIdx{except} blocks.
Then, there might be unanticipated errors for which we cannot define a reasonable \pythonilIdx{except} block.
In the latter case, the program should terminate and the \pgls{stackTrace} should be printed.

However, there may be situations where we do not just want to immediately quit be perform some necessary actions beforehand.
A typical example of this is if we are currently writing contents to a file.
Let's say we are writing a table of data row by row into a text file, and suddenly some unexpected error occurs.
If we terminate immediately without closing the file, then the contents of the complete file could be lost.
If we close the file before terminating, then at least the data that was successfully written so far will be preserved.
By terminating the program, we would still indicate to the user that there is some serious problem that needs attention.
But at least we would not destroy the data that was correctly produced.

For this purpose, the \pythonilIdx{try}-\pythonilIdx{finally} block exists.
Basically, we can add a \pythonilIdx{finally} block that contains the code that should always be executed.
While we definitely need a \pythonilIdx{try} block that contains that code that may cause an error, we can optionally add \pythonilIdx{except} blocks to handle certain \pythonilsIdx{Exception} and an \pythonilIdx{else} block to be executed if no error occurs.%
%
\begin{pythonSyntax}
try:  # Begin the try-except block.
    # Code that may raise an exception or that
    # calls a function that may rise one.
except ExceptionType1 as ex1:  # The **optional** except blocks.
    # Code the handles exceptions of type ExceptionType1.
# ... maybe more `except` blocks
else:  # The **optional** else block.
    # Code executed if and only if no Exception occurred.
finally:  # The **optional** finally block.
    # Code will always be executed, even if exceptions are uncaught.

next statement  # Executed only if there are no uncaught Exceptions.
\end{pythonSyntax}
%
\gitPythonAndErrorOutput{\programmingWithPythonCodeRepo}{exceptions}{try_except_else_finally.py}{--args format}{exceptions:try_except_else_finally}{%
An example for the \pythonilIdx{try}-\pythonilIdx{except}-\pythonilIdx{else}-\pythonilIdx{finally} block.}%
%
\gitOutputTool{\programmingWithPythonCodeRepo}{.}{_scripts_/mypy.sh exceptions try_except_else_finally.py}{exceptions:try_except_else_finally:mypy}{%
The results of static type checking with \mypy\ of the program given in \cref{lst:exceptions:try_except_else_finally}.}
%
\begin{sloppypar}%
Let us explore this in another artificial example in \cref{lst:exceptions:try_except_else_finally}.
Here, we create the function \pythonil{divide_and_print} that accepts two parameters~\pythonil{a} and~\pythonil{b} which can either be integers or floating point numbers.
In a \pythonilIdx{try} block, the function attempts to divide~\pythonil{a} by~\pythonil{b} and \pythonil{print} the result using an \pgls{fstring}.
Since we do not know exactly what values \pythonil{b} can take on beforehand, we anticipate that a \pythonilIdx{ZeroDivisionError} may occur.
In the corresponding \pythonilIdx{except} block, we would then print a message that explains the situation.
In this case, the division result would not be printed because the \pythonilIdx{try} block would terminate when the \pgls{fstring} is interpolated.%
\end{sloppypar}%
%
We also attempt to catch a possible \pythonilIdx{TypeError}.
Such an error would occur if the function is invoked by an argument that is neither an \pythonil{int} nor a \pythonil{float} and that does not support divison.
This is a typical example for an error that we should \emph{not} attempt to catch.
This error could only appear if another programmer was using our function incorrectly.
We only process this error here for the sake of the example and print an appropriate message in the \pythonilIdx{except} block.

In the example, we also have an \pythonilIdx{else} block which notifies us that no error occurred.
The code in this block is only executed if no \pythonilIdx{ZeroDivisionError} and no \pythonilIdx{TypeError} and also no other exception was raised.

We finish the division and error handling part of the function with a \pythonilIdx{finally} block.
This block will be executed if no exception was raised anywhere, but also if a \pythonilIdx{ZeroDivisionError}, \pythonilIdx{TypeError}, or other exception were raised.
Even if an error was raised \emph{inside} one of the \pythonilIdx{except} blocks, this code would be executed.
It will print that the division code was completed.

Then, in the last line of the function after the whole \pythonilIdx{try}-\pythonilIdx{except}-\pythonilIdx{else}-\pythonilIdx{finally} blocks, we print yet another message.
This code outside the blocks is reached only if either no error occurred at all or if the error was handled by one of the two \pythonilIdx{except} blocks (without yet another error).

In \cref{exec:exceptions:try_except_else_finally}, we show the \pgls{stdout} and \pgls{stderr} for invoking this function with several different arguments.
For \pythonil{divide_and_print(10, 5)}, both the division result in the \pythonilIdx{try} block as well as the messages from the \pythonilIdx{else} block, the \pythonIdx{finally} block, and from the very end of our function are printed.
\pythonil{divide_and_print(3, 0)} will cause a \pythonilIdx{ZeroDivisionError}.
Therefore, the \pythonil{print} instruction in the \pythonilIdx{try} block is not completed as interpolating the \pgls{fstring} already fails.
The first \pythonilIdx{except} block, which handles the \pythonilIdx{ZeroDivisionError}, is executed and prints its message.
The \pythonilIdx{else} block is not reached but the \pythonilIdx{finally} block prints its message.
Since the error was properly handled, the message in the \pythonil{print} instruction at the end of the function is written to the output as well.

Invoking \pythonil{divide_and_print("3", 0)} means that we intentionally ignore the \pglspl{typeHint} in the function definition.
The \python\ interpreter allows us to do this without complaint, as \pglspl{typeHint} are only hints and strict requirements (as in other programming languages like~\pgls{Java} or~\pgls{C}).
However, the division \pythonil{a / b} will fail since the string \pythonil{"3"} does not support a division operation.
It raises\pythonIdx{raise} a \pythonilIdx{TypeError}, which is subsequently caught by our second \pythonilIdx{except} block.
This means that the \pythonilIdx{else} block is again not reached.
The \pythonilIdx{finally} block is executed still and so is the \pythonilIdx{print} at the bottom of our function, since the \pythonilIdx{TypeError} was properly handled.
By the way, had we applied the static type checker \mypy\ to \cref{lst:exceptions:try_except_else_finally}, it would have informed us that we here try to call \pythonil{divide_and_print} with an invalid argument, as shown in \cref{exec:exceptions:try_except_else_finally:mypy}.

Finally, we attempt to compute \pythonil{divide_and_print(10 ** 313, 1.0)}, i.e., to calculate~$\frac{10^{313}}{1}$.
At first glance, this looks totally fine.
However, back in \cref{sec:float:special}, we learned about the limits of the datatype \pythonilIdx{float}.
Indeed, the \pythonilIdx{int} $10^{313}$ is outside the range of numbers that a \pythonilIdx{float} can represent.
By trying to divide it by \pythonil{1.0}, we force it to be converted to \pythonilIdx{float} first.
This will raise an \pythonilIdx{OverflowError}.
We do not have an \pythonilIdx{except} block for handling \pythonilsIdx{OverflowError}.
This means that, of course, no message is printed by the \pythonilIdx{try} block, none of our \pythonilIdx{except} blocks are reached, and the \pythonilIdx{else} block is not executed either.
The \pythonilIdx{finally} block, however, \emph{is} executed and prints its message to the output.
Since we did not catch the \pythonilIdx{OverflowError}, the code after our blocks at the bottom of our function is not executed.
Instead, our function is terminated immediately after the \pythonilIdx{finally} block completes.
Since there is no \pythonilIdx{try}-\pythonilIdx{except} block able to catch \pythonilsIdx{OverflowError} wrapped around the function call, the whole \python\ interpreter terminates as well.
It again prints the \pgls{stackTrace}, which informs us which error occured and where it happened.%
%
\FloatBarrier%
\endhsection%
%
%
\hsection{The \texttt{with} Block and Context Managers}%
\label{sec:withAndContextManagers}%
%
\gitPythonAndOutput{\programmingWithPythonCodeRepo}{exceptions}{file_try_finally.py}{--args format}{exceptions:file_try_finally}{%
Using \pythonilIdx{try}-\pythonilIdx{finally} for closing files after writing to and reading from them\pythonIdx{os!remove}\pythonIdx{remove}\pythonIdx{close}\pythonIdx{IO}\pythonIdx{IO!close}\pythonIdx{IO!write}\pythonIdx{write}\pythonIdx{readline}\pythonIdx{IO!readline}.}%
%
\gitOutputTool{\programmingWithPythonCodeRepo}{.}{_scripts_/ruff.sh exceptions file_try_finally.py}{exceptions:file_try_finally:ruff}{%
The output of \ruff\ when applied to \cref{lst:exceptions:file_try_finally}: It suggests using context managers instead of \pythonilIdx{try}-\pythonilIdx{finally}\pythonIdx{open}.}
%
\gitOutputTool{\programmingWithPythonCodeRepo}{.}{_scripts_/pylint.sh exceptions file_try_finally.py}{exceptions:file_try_finally:pylint}{%
The output of \pylint\ when applied to \cref{lst:exceptions:file_try_finally}: It suggests using the \pythonilIdx{with}~statement instead of \pythonilIdx{try}-\pythonilIdx{finally}.}
%
The \pythonilIdx{try}-\pythonilIdx{finally} block allows us to make sure that one action will always be performed, regardless if some other intermediate code fails (and raises exceptions).
A use case for this is handling resources that need to be explicitly closed after some time.
Typical examples for this are network connections or file input/output.
We will discuss both of these topics eventually much later.

Still, let us use file~I/O as an example here anyway in \cref{lst:exceptions:file_try_finally}.
In this file, we will create and open a text file \textil{example.txt}.
We will write a line of text into the file and then close it.
Then we will open it again, read the text, and print it to the \pgls{stdout}.
At the end, we will delete the file to not leave it laying around.

For that purpose, we first import the function~\pythonilIdx{remove}\pythonIdx{os!remove} from the module~\pythonilIdx{os}.
We also import the type~\pythonilIdx{IO} from the \pythonilIdx{typing}~module.
\pythonIdx{IO} is the basic type for text-based input/output streams and will later use it as \pgls{typeHint}.

We open the file \textil{example.txt} for writing.
To do so, we call the built-in function~\pythonilIdx{open}.
We pass in the filename~\textil{"example.txt"} as first parameter.
The second parameter, \pythonil{mode}\pythonIdx{open!mode}, is set to~\pythonil{"w"}, which means \inQuotes{open for writing.}
The parameter \pythonil{encoding}\pythonIdx{open!encoding} is set to~\pythonil{"UTF-8"}\pythonIdx{UTF-8}, which defines that the text should be translated to binary form when it is stored in the file via the usual \pgls{utf8}~encoding~\cite{RFC3629,ISOIEC106462020ITUCCSU}.
This is of no importance here and we will discuss this eventually later in the book.

Anyway, if opening the text file succeeds, we now have a variable~\pythonil{stream_out}, which is an instance of~\pythonilIdx{IO}.
We must make sure to definitely close this so-called text stream again, regardless what happens from now on.
We know that this can be done with a \pythonilIdx{try}-\pythonilIdx{finally} statement.
We simply put \pythonil{stream_out.close()}\pythonIdx{close}\pythonIdx{IO!close} into the \pythonilIdx{finally}~block.
It will thus definitely be called.
Into the \pythonilIdx{try}~block, we put \pythonil{stream_out.write("Hello world!")}.
This line will write the string~\pythonil{"Hello world!"} to the file.
This could, of course, fail.
Maybe our hard disk does not have enough space left to store this string.
But even if it fails, the \pythonilIdx{finally} block will make sure to close the file.

So after the block, the file is closed.
We could now open it in a text editor and would find in there the text that we had written.
Instead, we want to use code to read the text again right away.

For this purpose, we open the stream again, this time for reading.
This works exactly as opening for writing.
Instead of supplying \pythonil{mode="w"}, we could write~\pythonil{mode="r"}, meaning \inQuotes{open for reading.}
However, \pythonil{"r"} is the default value for the parameter \pythonil{mode}\pythonIdx{open!mode}, so we can just omit it.
Therefore, \pythonil{stream_in = open("example.txt", encoding="UTF-8")}\pythonIdx{open!encoding}\pythonIdx{UTF-8}\pythonIdx{open} it is.
Once the file is opened for reading, we must again make sure to close it eventually.
We do this again with \pythonilIdx{try}-\pythonilIdx{finally} statement, where we put \pythonil{stream_in.close()}\pythonIdx{close}\pythonIdx{IO!close} into the \pythonil{finally}~block.

The line of text that we had written before can now be read in the \pythonilIdx{try}~block.
This is done via~\pythonil{stream_in.readline()}\pythonIdx{readline}\pythonIdx{IO!readonline}.
And, as you can see, it gets immediately written to the \pgls{stdout} via~\pythonil{print}.

At the end of our program, we delete the \textil{example.txt} by calling~\pythonil{remove("example.txt")}\pythonIdx{remove}\pythonIdx{os!remove}.
We had imported the \pythonilIdx{remove}\pythonIdx{os!remove} function from the module~\pythonilIdx{os} exactly for this purpose.

In summary, the output of our program, given in \cref{lst:exceptions:file_try_finally} looks exactly as expected.
Since we are diligent programmers, we will, of course, also perform static code analysis by using tools such as \ruff\ and \pylint.
Their output can be found in \cref{exec:exceptions:file_try_finally:ruff,exec:exceptions:file_try_finally:pylint}.
Oddly enough, they complain:
\ruff\ suggests to use a \inQuotes{context manager} instead of the \pythonilIdx{try}-\pythonilIdx{finally} statement.
\pylint\ suggests to go with a \pythonilIdx{with}~statement instead.
They both mean the same.

\cquotation{PSF2024WSCM}{%
A context manager is an object that defines the runtime context to be established when executing a \pythonilIdx{with} statement. %
The context manager handles the entry into, and the exit from, the desired runtime context for the execution of the block of code. %
[\dots] %
Typical uses of context managers include saving and restoring various kinds of global state, locking and unlocking resources, closing opened files, etc.}%
%
The \pythonilIdx{with} statement has the following syntax, where the \pythonil{expression} is supposed to return a context manager~\cite{PSF2024WSCM,PSF2024CUFWSC,PSF2024TWS,PEP343}.%
%
\begin{pythonSyntax}
with expression as variable:
    # block of code that works with variable

# or

with expression:
    # block of code
\end{pythonSyntax}
%
Right now, we are still lacking some background knowledge needed to discuss what a context manager exactly is or how it works.
We will therefore do this later in \cref{sec:dunder:contextManager}.
However, in a nutshell, a context manager is basically an object that has two special methods.
The first one will be called right at the beginning of the \pythonilIdx{with} block, and its result will be stored in a local \pythonil{variable} (if the \pythonilIdx{with} block has the \pythonil{with expression as variable:}-shape).
The second special method will be called after the end of the \pythonilIdx{with} block.
This is always done, regardless whether an exception occurred inside the indented block of code directly under~\pythonilIdx{with}.

This makes the syntax roughly equivalent to calling the first special method before a \pythonilIdx{try} block and the second special method in the corresponding \pythonilIdx{finally} block.
It is just much shorter and looks more elegant.

\gitPythonAndOutput{\programmingWithPythonCodeRepo}{exceptions}{file_with.py}{--args format}{exceptions:file_with}{%
Using a \pythonilIdx{with}~block for closing files after writing to and reading from them\pythonIdx{os!remove}\pythonIdx{remove}\pythonIdx{IO!write}\pythonIdx{write}\pythonIdx{readline}\pythonIdx{IO!readline}.}%

Many of \python's resource-related \pglspl{API} are realized as context managers.
This also holds for the file input/output API.
We now rewrite \cref{lst:exceptions:file_try_finally} using a \pythonilIdx{with} block as \cref{lst:exceptions:file_with}.
The first thing you will notice is that the file is much shorter.
It is now 13~lines of code instead of~20.
It is also much easier to read and clearer.
We do no longer need to call the \pythonilIdx{close} methods of the streams.
They will automatically be invoked at the end of the \pythonilIdx{with} statements' bodies.%
%
\FloatBarrier%
\endhsection%
%
\endhsection%
%
%
\hsection{Testing Exceptions}%
\label{sec:testingExceptions}%
%
\gitPython{\programmingWithPythonCodeRepo}{exceptions/test_sqrt_raise.py}{--args format}{exceptions:test_sqrt_raise}{%
A \pgls{unitTest} checking that our new variant of the \pythonil{sqrt} function given in \cref{lst:exceptions:sqrt_raise} properly raises an \pythonilIdx{ArithmeticError} if its input is non-finite or negative.}%
%
\gitOutputTool{\programmingWithPythonCodeRepo}{.}{_scripts_/pytest.sh exceptions test_sqrt_raise.py}{exceptions:test_sqrt_raise:pytest}{%
The output of the \pglspl{unitTest} in \cref{lst:exceptions:test_sqrt_raise}: %
The \pythonilsIdx{ArithmeticError} are correctly raised.}%
%

Back in \cref{sec:unitTesting}, we introduced the concept of \pglspl{unitTest} and show how the tool \pytest\ can be used to test our functions.
We stated in \cref{bp:unitTestCoverage} that we should cover all the branches of the control flow inside a function with \pglspl{unitTest}.
One kind of branch that is often overlooked are \pythonilsIdx{Exception} and extension handling~\cite{LRBP2021AEHTPIOSL}.

If our function is supposed to \pythonilIdx{raise} a certain exception in some cases, then we should have a \pgls{unitTest} that checks if this \pythonilsIdx{Exception} is actually raised as it should be.
Now, any exception raised by a \pgls{unitTest} will cause the test to fail.
This seems to contradict our goal to intentionally raise the exceptions.
Luckily, \pytest\ offers us a device for this.

Let us expand our \cref{lst:functions:test_my_math_2} for testing the \pythonil{sqrt} function to now also test for \pythonilsIdx{ArithmeticError}.
The \pythonilIdx{pytest} module offers a so-called context manager~\cite{PSF2024CUFWSC} named \pythonilIdx{raises}.
If we want to check whether a function indeed raises a certain exception of type \pythonil{ExpectedExceptionType} for a given input, then we can wrap the corresponding function call into \pythonil{with raises(ExpectedExceptionType):}.
This is block tells the \pytest\ system that, in the following, indented, block, we expect that a certain exception must be raised.
If such an exception is not raised, the test fails.
If it is raised, the text succeeds.

\gitPython{\programmingWithPythonCodeRepo}{exceptions/test_sqrt.py}{--args format}{exceptions:test_sqrt}{%
Two \pglspl{unitTest} checking the original variant of the \pythonil{sqrt} function from back in \cref{lst:functions:test_my_math_2} that does not raise errors.}%
%
\gitOutputTool{\programmingWithPythonCodeRepo}{.}{_scripts_/pytest.sh exceptions test_sqrt.py}{exceptions:test_sqrt:pytest}{%
The output of the \pglspl{unitTest} in \cref{lst:exceptions:test_sqrt}: %
No error was raised in it, so the first test fails. %
The error message in the second test does not fit, so it fails as well.}%
%
In particular, we can provide the exception class as well as a \pgls{regex} via the parameter~\pythonil{match} to \pythonilIdx{raises}.
If the block does not raise an exception of the expected type, the test fails.
If it does raise a corresponding exception, then it will be converted to a string.
The string is then matched against the \pgls{regex} and if it indeed matches, the test succeeds.
If it does not match, then the test fails.%
%
\begin{sloppypar}%
But what is a \pgls{regex}?
We will learn this later as well, in a part of the book that is not yet written.
For now, let's say that a \pgls{regex} is a string pattern that can be compared with another string.
For example, the \pythonil{"sqrt.* is not permitted."} that we use in \cref{lst:exceptions:test_sqrt_raise} is such a \pgls{regex}.
All the \inQuotes{normal} characters in this string must match exactly gainst characters in the text it is compared against.
The only thing that makes it different from a normal string is the \textil{.*} that it contains.
The dot~(\textil{.}) can be replaced with any other character and the star~(\textil{*}) says that arbitrarily many such arbitrary characters are allowed.
\pythonil{"sqrt.* is not permitted."} would thus match against \pythonil{"sqrt is not permitted."}, \pythonil{"sqrt(1) is not permitted."}, \pythonil{"sqrt(inf) is not permitted."}, but not \pythonil{"sqrt is wrong."}.
Therefore, our produced error message must follow this pattern for the test to work.
And, as you can find in the \pytest\ output in \cref{exec:exceptions:test_sqrt_raise:pytest}, for the values \pythonil{v in [-1.0, inf, -inf, nan]}, no error is reported.
For these values, our \pythonil{sqrt} function does indeed raise\pythonIdx{raise} the expected \pythonilsIdx{Exception}, with the expected error messages.
The \pgls{unitTest} succeeds.%
\end{sloppypar}%
%
In \cref{lst:exceptions:test_sqrt}, we write a similar test.
This time, we use basically the original version of our \pythonil{sqrt} function which does not by itself raise any exception.
This function is directly implemented in the listing, in the same way as we did in \cref{lst:functions:my_math_2}, and again called \pythonil{sqrt}.
We also write two \pglspl{unitTest} into the new file \textil{test_sqrt.py}.
Both are intentionally designed to show what happens if either an expected exception is not raised~(\pythonil{test_sqrt_1}) or if its error message does not match the \pythonil{match} argument~(\pythonil{test_sqrt_2}).%
%
\begin{sloppypar}%
\pythonil{test_sqrt_1} simply feeds the value \pythonil{-1.0} to \pythonil{sqrt}.
It expects that an \pythonilIdx{ArithmeticError} should be raised.
It does not provide a specific \pythonil{match} \pgls{regex} against which the error message should be compared.
The output in \cref{exec:exceptions:test_sqrt:pytest} shows us that this test fails.
If the code inside the \pythonil{with raises(ArithmeticError):} does not actually raise\pythonIdx{raise} an \pythonil{ArithmeticError}, the test fails.%
\end{sloppypar}%
%
\begin{sloppypar}%
The second test case, \pythonil{test_sqrt_2}, is a bit more interesting.
It specifies \pythonil{with raises(ArithmeticError, match="sqrt.* is not permitted.")}, just like the tests in \cref{lst:exceptions:test_sqrt_raise} for the \pythonil{sqrt} function that does raise \pythonilsIdx{ArithmeticError}.
No we do know that our original \pythonil{sqrt} from \cref{lst:functions:my_math_2} does not raise such errors \dots\ by itself.
However, we try to compute \pythonil{sqrt(10 ** 320)}.
This very large integer values will eventually be converted to a \pythonil{float} inside our function.
This will fail, because it is too large, as we just discussed back in \cref{sec:tryFinally}.
This failure results in an \pythonilIdx{OverflowError}.
\pythonilsIdx{OverflowError} are a special case of \pythonilIdx{ArithmeticError} (see later in \cref{fig:pythonExceptions}).
So indeed, this does fulfill our testing requirement:
If an \pythonilsIdx{OverflowError} is also a \pythonilIdx{ArithmeticError}, so the right type of exception was raised.
However, its error message will not fit to our \pythonil{match} argument.
Therefore, the \pgls{unitTest} still fails.
The output of \cref{exec:exceptions:test_sqrt:pytest} explains this clearly.%
\end{sloppypar}%
%
With \pytest, we can now therefore\pythonIdx{pytest}:%
%
\begin{enumerate}%
%
\item Test whether a function computes the expected output for selected (correct) inputs. %
If it does not, the test fails.%
%
\item Test whether a function does not raise\pythonIdx{raise} an unexpected exception for the selected (correct) inputs. %
If it does raise one, the test fails.%
%
\item Raises the expected \pythonilsIdx{Exception} for selected (wrong) inputs with the correct error messages. %
If it does not, the test fails. %
We do this by using the \pythonil{with raises(...)}\pythonIdx{raises} statement.%
%
\end{enumerate}%
%
This allows us to cover both the expected and correct use of our function with tests as well as unexpected incorrect uses.
We can then be confident that our code is unlikely to cause harm, neither due to bugs created by ourselves nor due to accidental misuse by other programmers due to misunderstandings (which would immediately signaled to them by \pythonilsIdx{Exception}).
Notice that good \pglspl{unitTest} go hand in hand with good documentation in \pglspl{docstring}, because good \pglspl{docstring} reduce the chance of such misunderstandings.%
%
\bestPractice{testAll}{%
It is important to cover both the reasonable expected use of our functions as well as unexpected use with incorrect arguments with test cases. %
The latter case should raise\pythonIdx{raise} \pythonilsIdx{Exception}, which we should verify with \pglspl{unitTest}.%
}%
%
\FloatBarrier%
\endhsection%
%
\hsection{Built-in Exceptions}%
%
\begin{figure}%
\centering%
\renewcommand*\DTstylecomment{\relax}%
\renewcommand*\DTstyle{\small}%
%
\dirtree{%
.1 \pythonilIdx{BaseException}\DTcomment{the base \pythonilIdx{class} for all exceptions}.
.2 \pythonilIdx{Exception}\DTcomment{situations where reasonable error handling should be possible}.
.3 \pythonilIdx{ArithmeticError}\DTcomment{an arithmetic operation failed}.
.4 \pythonilIdx{FloatingPointError}\DTcomment{not used by \python, but, e.g., \pgls{numpy} on invalid floating point operations}.
.4 \pythonilIdx{OverflowError}\DTcomment{the result of an arithmetic operations is too large, see, e.g., \cref{sec:float:special}}.
.4 \pythonilIdx{ZeroDivisionError}\DTcomment{a division by zero occurred, see, e.g., \cref{sec:unitTesting}}.
.3 \pythonilIdx{AssertionError}\DTcomment{if an \pythonilIdx{assert} failed, see, e.g., \cref{sec:unitTesting}}.
.3 \pythonilIdx{BufferError}\DTcomment{a buffer-related operation could not be performed}.
.3 \pythonilIdx{EOFError}\DTcomment{the end of \pgls{stdin} was reached by \pythonilIdx{input} without reading data}.
.3 \pythonilIdx{AttributeError}\DTcomment{when an attribute reference or assignment failed}.
.3 \pythonilIdx{ImportError}\DTcomment{when an \pythonilIdx{import} statement fails}.
.4 \pythonilIdx{ModuleNotFoundError}\DTcomment{a module cannot be loaded}.
.3 \pythonilIdx{LookupError}\DTcomment{a key or index used on a dictionary or sequence was invalid}.
.4 \pythonilIdx{IndexError}\DTcomment{a sequence index is out of range, see, e.g., \cref{sec:strBasicOperations}}.
.4 \pythonilIdx{KeyError}\DTcomment{a dictionary key is not found, see, e.g., \cref{sec:dictionaries}}.
.3 \pythonilIdx{MemoryError}\DTcomment{when we are out of memory}.
.3 \pythonilIdx{NameError}\DTcomment{e.g., when reading an unassigned variable, see, e.g., \cref{lst:variables:assignment_wrong,lst:exceptions:try_multi_except}}.
.4 \pythonilIdx{UnboundLocalError}\DTcomment{reference to a local method or function to which no value is bound}.
.3 \pythonilIdx{OSError}\DTcomment{an operating system function failed}.
.4 \pythonilIdx{BlockingIOError}\DTcomment{a blocking operation is applied to an object set for non-blocking operations}.
.4 \pythonilIdx{ChildProcessError}\DTcomment{an operation on a child process failed}.
.4 \pythonilIdx{ConnectionError}\DTcomment{a connection- or pipe-related error}.
.5 \pythonilIdx{BrokenPipeError}\DTcomment{when trying to write into a pipe whose other end has been closed}.
.5 \pythonilIdx{ConnectionAbortedError}\DTcomment{connection attempt aborted by peer}.
.5 \pythonilIdx{ConnectionRefusedError}\DTcomment{connection refused by peer}.
.5 \pythonilIdx{ConnectionResetError}\DTcomment{connection reset by peer}.
.4 \pythonilIdx{FileExistsError}\DTcomment{trying to create a file that already exists}.
.4 \pythonilIdx{FileNotFoundError}\DTcomment{trying to access a file or directory that does not exist}.
.4 \pythonilIdx{IsADirectoryError}\DTcomment{trying to do a file operation with a directory}.
.4 \pythonilIdx{NotADirectoryError}\DTcomment{trying to apply a directory operation to a file}.
.4 \pythonilIdx{PermissionError}\DTcomment{trying to perform an operation without the necessary access rights}.
.4 \pythonilIdx{ProcessLookupError}\DTcomment{trying to access a process that does not exist}.
.4 \pythonilIdx{TimeoutError}\DTcomment{an operation timed out}.
.3 \pythonilIdx{ReferenceError}\DTcomment{a weakly-referenced object is accessed after being garbage collected}.
.3 \pythonilIdx{RuntimeError}\DTcomment{an error that does not fall into the other categories}.
.4 \pythonilIdx{NotImplementedError}\DTcomment{a method is not yet implement, but will be later, see, e.g., \cref{sec:inheritance}}.
.4 \pythonilIdx{PythonFinalizationError}\DTcomment{an operation is blocked during interpreter shutdown}.
.4 \pythonilIdx{RecursionError}\DTcomment{the maximum recursion depth of functions is reached}.
.3 \pythonilIdx{StopAsyncIteration}\DTcomment{signals the end of an asynchronous iteration; not an error}.
.3 \pythonilIdx{StopIteration}\DTcomment{signals the end of an iteration; not an error, see \cref{sec:iterable}}.
.3 \pythonilIdx{SyntaxError}\DTcomment{an malformed \python\ file}.
.4 \pythonilIdx{IndentationError}\DTcomment{incorrectly indented code}.
.5 \pythonilIdx{TabError}\DTcomment{inconsistent use of tabs and spaces}.
.3 \pythonilIdx{SystemError}\DTcomment{an internal error of the interpreter}.
.3 \pythonilIdx{TypeError}\DTcomment{some parameter was of a wrong type or \pythonilIdx{None}, see, e.g., \cref{sec:tuples}}.
.3 \pythonilIdx{ValueError}\DTcomment{a parameter has the right type but an inappropriate value, see, e.g., \cref{lst:exceptions:try_except_str_index}}.
.4 \pythonilIdx{UnicodeError}\DTcomment{an error when dealing with \pgls{unicode} text}.
.5 \pythonilIdx{UnicodeDecodeError}\DTcomment{an error occurred when decoding \pgls{unicode} text}.
.5 \pythonilIdx{UnicodeEncodeError}\DTcomment{an error occurred when encoding \pgls{unicode} text}.
.5 \pythonilIdx{UnicodeTranslateError}\DTcomment{an error occurred when translating \pgls{unicode} text}.
.2 \pythonilIdx{GeneratorExit}\DTcomment{when a \pythonilIdx{Generate} or coroutine terminate; not an error}.
.2 \pythonilIdx{KeyboardInterrupt}\DTcomment{when the user hits \keys{\ctrl+C}}.
.2 \pythonilIdx{SystemExit}\DTcomment{raised by \pythonilIdx{exit}; not an error}.
}%
%
\caption{An overview of the hierarchy of \pythonilsIdx{Exception} in \python~\cite{PSF2024BIE}.}%
\label{fig:pythonExceptions}%
\end{figure}%
%
A wide variety of things may go wrong during the execution of a computer program.
We have already explored a lot of different potential errors, ranging from using an invalid index when accessing a list to dividing a number by zero.
In \python, \pythonilsIdx{Exception} are raised\pythonIdx{raise} in such a situation.
An \pythonilIdx{Exception} disrupts the normal control flow and propagates upwards until a corresponding \pythonilIdx{except} clause is reached.
Obviously, we cannot just treat every possible error condition in the same way.

Running out of memory is a completely different situation than trying to read from a non-existing file.
Therefore, different types of exceptions are raised:
The former problem causes a \pythonilIdx{MemoryError} while the later raises an \pythonilIdx{FileNotFoundError}.
The hierarchy of the different problem types is illustrated in \cref{fig:pythonExceptions}~\cite{PSF2024BIE}.
There, you can also see why an \pythonilIdx{except} block catching \pythonilsIdx{ArithmeticError} would also catch an \pythonilsIdx{OverflowError}, because the latter is a special case of the former.

Depending on the operations that your code tries to perform, you would wrap it into \pythonilIdx{except} blocks for the errors from this list that you could reasonably expect to be able to recover from.
Of course, the documentation of the \python\ functions that you use will tell you which exceptions it could raise.
And so should the \pglspl{docstring} of your own code as well as library functions you rely on.%
\endhsection%
%
\hsection{Summary}%
In this chapter, we have dealt with a very important subject in programming:
How we handle errors.
Errors can arise from a wide variety of reasons.

They can be caused by invalid or corrupted data being passed to our program.
In this case, our program should fail and print an error message to the user.

They can be caused by a programming mistake:
Maybe another programmer uses a function that we have written, but passes a parameter of a wrong type to it.
For example, maybe they pass in a string where we expect a number.
Or maybe they pass a negative number when we expect a positive one.
In this case, our program should fail and print an error message to the user.

Failing by raising an \pythonilIdx{Exception} is a good thing.
It clearly indicates that something is wrong.
It gives the user or our fellow programmers a chance to become aware of an error and to take action to fix it.
Other approaches, like \pgls{GIGO} or overly sanitizing corrupted input instead allow errors to propagate unnoticed.

Maybe some of the readers of this book are graduate or undergraduate students who use \python\ to implement code for experiments.
Imagine how annoying it is to run an experiment and to find out one week later that all the data produced is garbage.
You then not only feel sad about the waste of time, but now need to waste even more time:
Where was the error?
Maybe it would take another week to painstakingly debug your code step-by-step to find out that some function was used incorrectly due to a typo.
How much better would it have been if the experiment had crashed right at its start, printing an \pythonilIdx{Exception} and \pgls{stackTrace} to the \pgls{stdout} showing exactly where things went wrong?
It would have saved you two weeks and lots of grief.

Of course, there are also situations where it is possible to gracefully recover from an error.
For example, maybe our program is trying to delete a file that already has been deleted.
The operation would fail, but that does not do any harm.
For these scenarios, the \pythonilIdx{except} blocks exist.
They allow us to catch errors which we can reasonably expect and that are no show stoppers.

The \pythonilIdx{finally} block allows us to properly complete an operation regardless whether an error happened or not.
If we send data over an internet connection, we want to close this connection properly after we are done.
We also want to close it if something goes wrong.
If we write data to a file, then we want to close the file once we are done.
We still want to close it properly if an error occurs, because then we can at least preserve the data that was already successfully written.

Compared to the \pythonilIdx{try}-\pythonilIdx{finally}~block, the \pythonilIdx{with}~statement adds more ease to handling of resources that need to be explicitly closed at some point in time.
Such resources can be implemented as context managers, whose special closing routine is automatically called at the end of the body of the \pythonilIdx{with}~statement.

Error handling in \python\ therefore allows us to develop software that is both robust and that clearly indicates if something goes wrong.
Of course, for software to be called \emph{robust}, it has to be tested.
Luckily, \pytest\ offers us also \pgls{unitTest} capabilities that check whether \pythonilsIdx{Exceptions} are raised where expected.
This completes our discussion of the error-related control flow.%
\endhsection%
%
\FloatBarrier%
\endhsection%
%
