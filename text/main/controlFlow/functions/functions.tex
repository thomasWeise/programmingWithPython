\hsection{Functions}%
%
Functions are blocks of code that can be invoked from anywhere else in a program.
You already learned many functions, from the basic \pythonilIdx{print} routine that just prints the value of its parameter to the output to the \pythonilIdx{sqrt} function from the \pythonilIdx{math} module which computes the square root.
Now you will learn how to make your own functions.%
%
\hsection{Defining and Calling Functions}%
%
\pythonIdx{def}%
The syntax for defining our own functions in \python\ is as follows:%
%
\begin{pythonSyntax}
def my_function(param_1: type, param_2: type, ...) -> result_type:
    """
    Short sentence describing the function.

    The title of the so-called docstring is a short sentence stating
    what the function does. It can be followed by several paragraphs of
    text describing it in more detail. Then follows the list of
    parameters, return values, and raised exceptions (if any).

    :param param_1: the description of the first parameter (if any)
    :param param_2: the description of the second parameter (if any)
    :returns: the description of the return value (unless `-> None`).
    """
    body of function 1
    body of function 2
    return result  # if result_type is not None we return something


normal statement 1
normal statement 2
my_function(argument_1, argument_2)  # we can call the function like this
\end{pythonSyntax}
%
\pythonIdx{function!def}A function in \python\ is created by using the \pythonilIdx{def} keyword, followed by the name of the function.%
%
\bestPractice{functionNames}{Function names should be lower case, with underscores separating multiple words if need be~\cite{PEP8}.}%
%
\pythonil{function!parameters}Then follows an opening and a closing parenthesis, i.e., \pythonil{(...)}\pythonIdx{(\idxdots)}.
A function can have parameters through which we can pass values to it.
Inside the function, these parameters act like variables.
The values of these variables can be passed in when we call (invoke, execute) the function.
Notice that, just like variables, all such parameters should be annotated with type hints~(see \cref{sec:variableTypesAndTypeHints}).
Functions can return results~(like the \pythonilIdx{sqrt} function of the \pythonilIdx{math} module does) or return nothing~(like \pythonilIdx{print}).
\pythonIdx{function!return value}If they return a result, the type of this result is specified via the type hint \pythonil{ -> result_type}\pythonIdx{->}.
The function header ends with a colon~(\pythonilIdx{:}).%
%
\bestPractice{functionTypeHints}{%
All parameters and the return value of a function should be annotated with type hints. %
From my perspective: \emph{A function without type hints is wrong.}%
}%
%
Then, indented by four spaces, follows the function body.%
%
\bestPractice{functionBodyIndentation}{The body of a function is indented with four spaces.}%
%
\pythonIdx{function!body}This can be an arbitrary block of code, which may contain all the things we already learned.
\pythonIdx{function!return}The function can, at any point, be left using the \pythonilIdx{return} statement.
If the function is supposed to return a value \pythonil{result}, then this is done via \pythonil{return result}.
Notice that, like the \pythonilIdx{break} statement in loops, we can place \pythonilIdx{return} at any location we want.
We can also have multiple \pythonilIdx{return} values at different places in the function.%
%
\begin{sloppypar}%
\pythonIdx{function!call}The function \pythonil{my_function} then can be called from anywhere in the code by writing \pythonil{my_function(value_1, value_2, ...)}, where \pythonil{value_1} is passed in as value of \pythonil{param_1}, \pythonil{value_2} is passed in as value of \pythonil{param_2}, and so on.
This follows the same pattern of function calls that we already used in many of our examples.%
\end{sloppypar}%
%
\pythonIdx{function!docstring}\pythonIdx{str!doc!function}%
Between the header of a function and its body, we always need to place a so-called \pgls{docstring}, which is a multi-line string~(see \cref{sec:multiLineStrings}).
This string consists of a title line shortly describing what the function does.
After an empty line, we can (but not necessarily need to) place a paragraph of text providing a more detailled discussion.
Then follows the list of parameters, each in the syntax \pythonil{:param parameter_name: description}\pythonIdx{:param:}.
Then follows the return value description (if the function returns something) in the form \pythonIdx{:returns: description}\pythonIdx{:returns:}.%
%
\bestPractice{funcDocstrings}{%
Each function should be documented with a \pgls{docstring}. %
If you work in a team or intend to place your code in public repositories like on \pgls{github}, then this very very much increases the chance that your code will be used correctly. %
From my perspective: \emph{A function without \pgls{docstring} is wrong.}%
}%
%
\bestPractice{functionSpace}{%
After the function and its body are defined, leave \emph{two} blank lines before writing the next code~\cite{PEP8}.%
}%
%
\gitPythonAndOutput{\programmingWithPythonCodeRepo}{05_functions}{def_factorial.py}{--args format}{functions:def_factorial}{%
Implementing a function computing the factorial of a positive integer number.}%
%
After all of this long introduction, let us finally come to some example.
Let's implement the factorial function as, well, function.
The factorial is defined as follows~\cite{D1991TEHOTFF,CB2022FBDOTFF}%
%
\begin{equation}%
\factorial{a}=\left\{\begin{array}{rl}%
1&\textnormal{~if~}a = 0\\%
\prod_{i=1}^a i&\textnormal{~otherwise, i.e., if~}a>0%
\end{array}\right.%
\label{eq:factorial}%
\end{equation}%
%
where $\prod_{i=1}^a i$ stands for the product~$1*2*3*\dots*(a-1)*a$.
We will implement this function in \python\ call it \pythonil{factorial} in \cref{lst:functions:def_factorial}.
It should take a single parameter~\pythonil{a} as parameter.
\pythonil{a} will be type-hinted as integer and the result of our function will be an integer as well.

The body of this function is straightforward.
We begin by initializing a variable \pythonil{product} with the value~\pythonil{1}.
Then, we need a loop that iterates a variable~$i$ over all integers less than or equal to~\pythonil{a}.
We want to multiply these values to~\pythonil{product}.
Well, we can skip over~$\pythonil{i}=1$, because that would be useless.
So we will use a \pythonilIdx{for} loop iterating~\pythonil{i} over the \pythonil{range(2, a + 1)}\pythonIdx{range}.
This effectively starts~\pythonil{i} at~\pythonil{2}.
Since the upper limit~\pythonil{a + 1} of the \pythonilIdx{range} is always \emph{exclusive}, the last value for~\pythonil{i} will be~\pythonil{a}.
Notice that we really use \pythonil{a} like a normal variable that was assigned a value.%
%
\begin{sloppypar}%
Anyway, inside the loop body, we compute \pythonil{product *= i}\pythonIdx{*=}, which is equivalent to \pythonil{product = product * i}.
After the loop, \pythonil{product} holds $\factorial{\pythonil{a}}$.
So we can return it as the result of the function, by writing \pythonil{return product}\pythonIdx{return}.%
\end{sloppypar}%
%
We can now compute the factorial of any number~\pythonil{x} by calling~\pythonil{factorial(x)}.
After the function body, we leave two empty lines.
And then we compute the factorials of the numbers from~$1$ to~$9$ in a \pythonilIdx{for}-loop and print them by using \pglspl{fstring}.
Inside this loop and in the \pgls{fstring}, we can use the function \pythonil{factorial} exactly like any other function we used before, like \pythonil{sqrt} or \pythonil{print}.
It may be an interesting side information at the end of this example that the factorial can actually be computed \emph{faster} than using this product form, see, e.g.~\cite{L2015ANKOFF}.

\gitPythonAndOutput{\programmingWithPythonCodeRepo}{05_functions}{def_gcd.py}{--args format}{functions:def_gcd}{%
Implementing the Euclidean Algorithm as a function and calling it from another function.}%

Functions can have a more than one parameter or no parameter at all.
They can return one value or return nothing at all.
Functions can also be called from other functions.
Let us investigate these options by investigating another interesting mathematical operation:
The computation of the greatest common divisor, also known as~\pythonil{gcd}.

This can be done using the Euclidean algorithm~\cite{EHF2008ENT,B1999FAOTBEA,TKY2016BEOEAOTCEG}, going back to \citeauthor{EHF2008ENT} who flourished about 300~BCE.
The greatest common divisor of two numbers positive~$a\in\naturalNumbersO$ and~$b\in\naturalNumbersO$ is the greatest number~$g\in\naturalNumbersO=\pythonil{gcd}(a,b)$ such that~$a\bmod g=0$ and~$b \bmod g=0$, where~$\bmod$ is the \pgls{modulodiv} operator equivalent to \python's~\pythonilIdx{\%}.
This means that $g$~divides both $a$ and $b$ without remainder.
If $a=b$, then obviously $\pythonil{gcd}(a,b)=a=b$ as well.
Otherwise, we know that $a=ig$ for some~$i\in\naturalNumbersO$ and $b=jg$ for some~$j\in\naturalNumbersO$.
If we assume, without loss of generality, that~$a>b$.
Then, $c=a-b=(i-j)g$ and it will be clear that $c\bmod g=(a-b)\bmod g=(i-j)g\bmod g = 0$ as well, i.e., that $\pythonil{gcd}(a,b)=\pythonil{gcd}(a-b, b)=g$.
Similarly, $d=a\bmod b=ig\bmod (jg)=ig-\lfloor i/j\rfloor*jg=g(i-j\lfloor i/j\rfloor)$ is still divisible by~$g$ without remainder as~$d\bmod g=0$.
This means that~$\pythonil{gcd}(a\bmod b, b)=\pythonil{gcd}(a, b)=g$, too.

Since both~$d$ and~$c$ are less than~$a$, we could replace~$a$ with either of them.
In particular, $d$~will be less than both~$a$ and~$b$, so we could store~$b$ in~$a$ and replace~$b$ with~$d$.
We would repeat the computation until reaching~$b=0$, at which point~$a$ will be~$g$.
Matter of fact, by choosing the module-based update, we do not even need to assume that~$a>b$.
Because if~$b>a$, then~$a \bmod b=a$ and we would just switch~$a$ and~$b$ in this step.
If~$a=b$, then~$a \bmod b=0$ and we would immediately terminate after the first step and return~$a$ as the greatest common divisor.

This algorithm is implemented in \cref{lst:functions:def_gcd} as function~\pythonil{gcd}.
\pythonil{gcd} has two integer parameters, \pythonil{a} and~\pythonil{b}, and returns another~\pythonil{int}.
Its body is surprising short:
We use a \pythonilIdx{while} loop that iterates as long as \pythonil{b > 0}.
After the loop, we \pythonil{return a}\pythonIdx{return} as the result.
If \pythonil{b == 0} holds at the beginning, the loop will never be executed and~\pythonil{a} is returned as-is, which is correct:
$\pythonil{gcd}(a, 0)=a$ for all~$a\in\naturalNumbersO$.

However, if \pythonil{b > 0}, we enter the loop's body, which is a single line of code:
the tuple-unpacking command~\pythonil{a, b = b, a \% b}~(see \cref{sec:lists}).\pythonIdx{tuple!unpacking}\pythonIdx{unpacking}
This line first completely evaluates the right-hand side.
This creates a tuple\pythonIdx{tuple} where the first value is~\pythonil{b}.
The second value is~\pythonil{a \% b}.
The tuple is then unpacked and stored in the variables~\pythonil{a} and~\pythonil{b}.
\pythonil{a} will thus receive the value that \pythonil{b}~had during the evaluation of the right-hand side.
\pythonil{b} will receive the previously computed value of~\pythonil{a \% b}.
In other words, \pythonil{b} is stored in~\pythonil{a} and the remainder of the division of \pythonil{a} by \pythonil{b} is stored in~\pythonil{b}.
Clearly, \pythonil{b} will become smaller in each iteration and since it can never become negative, it will eventually reach~\pythonil{0} and the loop will terminate.
Similarly, the \pythonil{gcd} is never \inQuotes{lost} during the loop and will thus be the value in~\pythonil{a} at the end.
And this value is returned.

So this was a function with two parameters and one return value.
Let us now implement a second function, this time with no return value.
\pythonil{print_gcd} accepts again two parameters~\pythonil{a} and~\pythonil{b} and returns nothing.
Instead, it will print the \pythonil{gcd} nicely using \pythonilIdx{print} and an \pgls{fstring}.
Since the \pythonilIdx{math} module also provides a function names \pythonilIdx{gcd} for computing, well, the greatest common divisor, we want to compare the result of our function with this one.%
%
\begin{sloppypar}%
Of course, we cannot have two functions named \pythonil{gcd} in the same context.
So we import the function from the \pythonilIdx{math} module \emph{under a different name}:
\pythonil{from math import gcd as math_gcd}\pythonIdx{as}\pythonIdx{import}\pythonIdx{from} makes the \pythonilIdx{gcd} function from the module \pythonilIdx{math} available under the name~\pythonil{math_gcd}.
And we use it in the \pgls{fstring} in \pythonil{print_gcd} under that name.%
\end{sloppypar}%
%
Finally, we confirm that \pythonil{gcd} and \pythonil{math_gcd} compute the same result for four test cases at the bottom of our program.
Now that all is said and done, it should be mentioned that the Euclidean Algorithm has a particularly efficient binary variant which is faster than our implementation in \cref{lst:functions:def_gcd}.
This binary variant may have been developed in China in the first century~CE~\cite{B1999FAOTBEA}.%
%
\FloatBarrier%
\endhsection%
%
\hsection{Functions in Modules}%
%
\gitPython{\programmingWithPythonCodeRepo}{05_functions/my_math.py}{--args format}{functions:my_math}{%
The module \pythonil{my_math}, which provides two mathematics functions, namely \pythonil{sqrt}, implementing the algorithm of Heron to compute the square root from \cref{lst:loops:while_loop_sqrt}, and \pythonil{factorial}, copied from \cref{lst:functions:def_factorial}.}%
%
You may not have noticed it, but we just made a very big step in our programming skills.
We moved from simple programs which only consist of one big block of code to modular programs.
We can now reuse code.
And we can distribute code over multiple files.
This clearly is a concern for any application larger than a simple script:
How can we avoid writing our applications as a single, huge, and unstructured file which would be impossible to maintain in the long run?
How can we divide our application into smaller units that we can test, improve, and maintain separately and maybe use and reuse in different contexts?
A big part of the answer to this question are \emph{modules} and \emph{packages}~\cite{PSF2024TIS}.

For all intents and purposes within this book, a \emph{module}\pythonIdx{module} is a \python\ file and a \emph{package}\pythonIdx{package} is a directory wherein the file is located.
As described in~\cite{PSF2024TIS}, modules do not necessarily need to be files and packages can probably be created otherwise as well, but let us keep it simple here.

Indeed, we have already worked with modules, most prominently the~\pythonilIdx{math} module.
This module is basically a collection of mathematical functions.
Since we have implemented several mathematical functions by ourselves, let us put some of them in a module as well.

In \cref{lst:functions:my_math} we do just that.
We create the \python\ file \textil{my_math.py} and place two functions into it:
The function \pythonil{factorial} from \cref{lst:functions:def_factorial} and a new function called \pythonil{sqrt}.
The \pythonil{sqrt} function basically encapsulates our code from back in \cref{lst:loops:while_loop_sqrt}, where we implemented the Heron's Method to compute the square root, as a function.
Now, \pythonil{number}, the input of this algorithm, comes in as a parameter.%
%
\bestPractice{packageAndModuleNames}{Package and module names should be short and lowercase. Underscores can be used to improve readability.~\cite{PEP8}}%
%
Our new module \textil{my_math} does not look very special or different from what we did so far.
The one difference that we notice, however, is that it \inQuotes{does nothing}.
In the file, we define two functions, but we do not actively call them, we do not use them for anything.
This is the purpose of this module:
It just provides the functions.
We will use them elsewhere.

\gitPythonAndOutput{\programmingWithPythonCodeRepo}{05_functions}{use_my_math.py}{--args format}{functions:use_my_math}{%
A program using the functions \pythonil{sqrt} and \pythonil{factorial} from the module \pythonil{my_math} given in \cref{lst:functions:my_math}.}%%
%
\begin{sloppypar}%
\Cref{lst:functions:use_my_math} is where we use them:
We write a program, i.e., another \python\ file, named \textil{use_my_math.py}.
In this file, we want to use our two functions \pythonil{factorial} and \pythonil{sqrt} from the module \pythonil{my_math}.
For this purpose, we have to tell the \python\ interpreter where it can find these two functions.
We do this by writing \pythonil{from my_math import factorial, sqrt}\pythonIdx{from}\pythonIdx{import}\pythonIdx{module}.
The meaning of the line is quite obvious:
There is a module \pythonil{my_math} from which we want to import, i.e., make available, two functions, namely \pythonil{factorial} and \pythonil{sqrt}.%
\end{sloppypar}%
%
Now, the \python\ interpreter knows a lot of modules.
Several modules ship with any \python\ installation, like \pythonilIdx{math}.
Others are installed via a package manager like \pgls{pip}~\cite{PSF2024IPM} (we will eventually discuss this later).
The \pythonil{my_math} module is found because it is in the same directory as the program \textil{use_my_math}.

If we had placed the \textil{my_math.py} file into a sub-directory named \textil{math_pack} instead, then we would import our functions from \textil{math_pack.my_math} instead, where \textil{math_pack} would be called a~\emph{package}.
Of course, we could also create another level of directories, say we could have directory \textil{utils}, containing directory \textil{math_pack}, containing our file \pythonil{my_math.py}.
In this case, we would import our functions like \pythonil{from utils.math_pack.my_math import}\dots.
The names of package and modul are separated by a~\pythonilIdx{.} when importing from them.
This allows us to nicely and hierarchically structure our projects into modules and packages for different purposes.

In \cref{lst:functions:use_my_math} we can use both \pythonil{sqrt} and \pythonil{factorial} exactly as if we had defined them in this program.
We first print a few values for \pythonil{sqrt} and \pythonil{factorial} and also show that we can compute the result of the square root of a factorial.
We also just copy the code from \cref{lst:loops:for_loop_pi_liu_hui}, where we use LIU Hui's method to approximate~\numberPi\ -- but this time, we use our own implementation of the square root function instead of the one from the \pythonil{math} module.
Interestingly, the sixth and last approximation step in \cref{exec:functions:use_my_math} shows exactly the same result as in \cref{exec:loops:for_loop_pi_liu_hui}.%
%
\FloatBarrier%
\endhsection%
%
\endhsection%
%
