\hsection{Loops}%
%
When we are working with sequences of data, we do not just want to perform an action on one data element.
We instead often want to apply the actions repetitively to all data elements.
Loops allow us to do just that, to perform the same actions multiple times.%
\pythonIdx{loop}%
%
\hsection{The \texttt{for} Loop Statement}%
%
\pythonIdx{loop!for}%
The most basic such sequence in \python\ may be the \pythonilIdx{for}~loop, which has the following pattern:%
%
\begin{pythonSyntax}
for loopVariable in sequence:
    loop body statement 1
    loop body statement 2
    # ...

normal statement 1
normal statement 2
# ...
\end{pythonSyntax}
%
%
\gitPythonAndOutput{\programmingWithPythonCodeRepo}{04_loops}{for_loop_range.py}{--args format}{loops:for_loop_range}{%
An example for using the \pythonilIdx{for} loop over a \pythonilsIdx{range} of integer numbers.}%
%
\gitPythonAndOutput{\programmingWithPythonCodeRepo}{04_loops}{for_loop_pi_liu_hui.py}{--args format}{loops:for_loop_pi_liu_hui}{%
A variant of \cref{lst:variables:pi_liu_hui} which uses a \pythonilIdx{for} loop instead of five copies of the same instructions.}%
%
The keyword~\pythonilIdx{for} is followed by a loop variable.
Then comes the keyword~\pythonilIdx{in}, the \pythonil{sequence} we want to iterate over, and finally a colon~(\pythonilIdx{:}).
This variable will iteratively take on the values in the \pythonil{sequence}.
The loop body statements in the following, indented block are executed for each of these values.
Each time the body of the loop is executed is called an~\emph{iteration}\pythonIdx{iteration} of the loop.
After the loop, we leave one blank line followed by the code that will be executed after the loop completes.

In its most simple form, the \pythonilIdx{for} loop is applied to a \pythonilIdx{range} of integer numbers.
Ranges are sequences which work basically like slices\pythonIdx{slice} (see \cref{sec:lists:basicFunctions,sec:strBasicOperations}).
\pythonil{range(5)} will give us a sequence of integers starting with~0 and reaching up to right \emph{before}~5, i.e., the integer range~\intRange{0}{4}.
\pythonil{range(6, 9)} gives the sequence of integers starting with~6 and stopping right \emph{before}~9, i.e., the integer range~\intRange{6}{8}.
Finally, \pythonil{range(20, 27, 2)} results in a sequence of integers that begins at~20, increments by~2 in each step, and ends right before~27.
This is the sequence~$(20, 22, 24, 26)$.
\pythonilsIdx{range}, like slices\pythonIdx{slice}, can also have negative increments:
The \pythonil{range(40, 30, -3)} starts with~40 and stops before reaching~30 and decrements by~3 in each step.
This is equivalent to the set~$(40, 37, 34, 31)$.

In \cref{lst:loops:for_loop_range}, we loop over exactly these ranges.
In this listing, we try to create a dictionary (see \cref{sec:dictionaries}) where some integer numbers are mapped to their squares.
We use four \pythonilIdx{for}~loops to fill this dictionary with data.
In each of these first four \pythonilIdx{for}~loops, we use \pythonil{i} as the loop variable.

When iterating over the \pythonil{range(5)} in the first loop, \pythonil{i} will hold the value \pythonil{0} in the first iteration (=~execution of the loop body).
The loop body \pythonil{squares[i] = i * i} will thus effectively be \pythonil{squares[0] = 0} and thus store the value~\pythonil{0} under key~\pythonil{0} into the dictionary \pythonil{squares}.
In the second iteration, \pythonil{i} will hold the value~\pythonil{1}.
Then, the body \pythonil{squares[i] = i * i} will effectively be \pythonil{squares[1] = 1}.
In the third iteration, \pythonil{i} will hold the value~\pythonil{2} and the body will perform \pythonil{squares[2] = 4}.
Next, \pythonil{i = 3} and \pythonil{squares[3] = 9} will be executed and in the laste iteration of the first loop, we store \pythonil{squares[4] = 16}.

In the second loop, which uses \pythonil{range(6, 9)}, \pythonil{i} will take on the values \pythonil{6}, \pythonil{7}, and \pythonil{8}, one by one.
The dictionary \pythonil{squares} will thus be extended with the values \pythonil{squares[6] = 36}, \pythonil{squares[7] = 49}, and \pythonil{squares[8] = 64}.
In the third loop, iterating over \pythonil{range(20, 27, 2)}, the following updates will be performed one by one \pythonil{squares[20] = 400}, \pythonil{squares[22] = 484}, \pythonil{squares[24] = 576}, and \pythonil{squares[26] = 676}.
In the fourth loop, \pythonil{i} takes on the values of the sequence \pythonil{range(40, 30, -3)}, which has the negative step length~\pythonil{-3}.
\pythonil{i} therefore first becomes~\pythonil{40}, then \pythonil{37} in the second iteration, then \pythonil{34}, and, finally,~\pythonil{31}.
We then print\pythonIdx{print} the dictionary and get the expected output in \cref{exec:loops:for_loop_range}.%
%
\bestPractice{underscore}{%
If we do not care about the value of a variable (or parameter), we should name it~\pythonil{_}\pythonIdx{\_}~\cite{PEP635}. %
This information is useful for other programmers as well as static code analysis tools.%
}%
%
At the end of \cref{lst:loops:for_loop_range} we show this special case:
We want to print\pythonIdx{print} \pythonil{"Hello World!"} three times.
Instead of copying the line \pythonil{print("Hello World!")} three times, we put it in a loop.
However, nowhere in the loop body we care about the value of the loop variable.
We thus simply call it \pythonil{_}\pythonIdx{\_}.
If we would not call it that, then another programmer seeing our code (or a static code analysis tool for that matter) could be confused as to why we do not use the loop variable.
Always remember that \inQuotes{real} code could be much more complicated, and any semantic hint we can include to convey our intentions will be helpful.

With these new tools at hand, we can revisit our program \cref{lst:variables:pi_liu_hui} for approximating~\numberPi\ from back in \cref{sec:approximatePiLiuHui}.
In this program, we executed the same code five times.
Instead of doing this, we can put this into a loop, which reduces the lines of code from over~25 to about~10 in \cref{lst:loops:for_loop_pi_liu_hui}.
The outputs in \cref{exec:variables:pi_liu_hui,exec:loops:for_loop_pi_liu_hui} are exactly the same.%
%
\FloatBarrier%
\endhsection%
%
\hsection{The \texttt{continue} and \texttt{break} Statements}%
%
\gitPythonAndOutput{\programmingWithPythonCodeRepo}{04_loops}{for_loop_continue_break.py}{--args format}{loops:for_loop_continue_break}{%
An example for the \pythonilIdx{continue} and \pythonilIdx{break} statements in a \pythonilIdx{for} loop.}%
%
Loops often have complex bodies, maybe containing conditional statements or other loops.
It is not an uncommon situation that, after performing some computations in the body of the loop, we already know that we can continue directly with the next iteration instead of executing the remainder of the loop body.
Sometimes we also find that we can entirely stop with the loop and continue with whatever instructions come after it, even if we did not yet exhaust the sequence over which we are iterating.
The former can be achieved using the \pythonilIdx{continue} and the latter with the \pythonilIdx{break} statement.

An example for both statements is given in \cref{lst:loops:for_loop_continue_break}.
Here, we iterate the variable~\pythonil{i} over the 15~values from~\pythonil{0} to~\pythonil{14}.
In the loop body, we first create a string~\pythonil{s} with the current value of~\pythonil{i} via the \pgls{fstring} \pythonil{f"i is now \{i\}."}
The very last instruction of the loop body, \pythonil{print(s)}\pythonIdx{print}, prints this string.

While \pythonil{i} would go from~\pythonil{0} to~\pythonil{14}, we actually want to abort the loop as soon as \pythonil{i} becomes greater than~\pythonil{10}.
Instead of modifying the \pythonilIdx{range} over which we loop (which would be reasonable), we here want to use the \pythonilIdx{break} statement.
We therefore wrap it into the conditional \pythonil{if i > 10:}, meaning that it will only be executed if~\pythonil{i > 10}.
As soon as \pythonilIdx{break} is reached, the loop will immediately be aborted.
No further instruction in the loop body is executed and no further iteration is performed.
Instead, the process will continue after the loop, with the line~\pythonil{print("All done.")}.

If \pythonil{i > 10} did not hold, the rest of the loop body is executed.
For the case that $\pythonil{i}\in\intRange{5}{8}$, we now want to directly jump to the next loop iteration by invoking the \pythonilIdx{continue}~statement.
This means that if \pythonil{i == 5}, the \pythonilIdx{continue}~statement lets the control directly return to the head of the loop, which will set~\pythonil{i = 6}.
This will happen until~\pythonil{i == 9}.
The condition \pythonil{5 <= i <= 8} is \emph{not} met for all $\pythonil{i}\in\intRange{0}{4}\cup\intRange{9}{15}$.
The next line, namely the \pythonil{print(s)}\pythonIdx{print}, can only be reached in these cases.
Of course, we already know that we will never even reach this code as soon as \pythonil{i == 11}.

As a result the program will print the string~\pythonil{s} only for~$\pythonil{i}\in\intRange{0}{4}\cup\{9, 10\}$ before finally outputting~\textil{All done.}.
This can be observed in the program output collected in \cref{exec:loops:for_loop_continue_break}.
With \pythonilIdx{break} and \pythonilIdx{continue}, we now have two tools that can help us to either abort any loop prematurely or to abort the current iteration of the loop prematurely (and continue with the next one, if any), respectively.%
%
\FloatBarrier%
\endhsection%
%
\hsection{Nesting Loops}%
%
\gitPythonAndOutput{\programmingWithPythonCodeRepo}{04_loops}{for_loop_nested_primes.py}{--args format}{loops:for_loop_nested_primes}{%
Computing a list of all primes from \intRange{2}{200} using nested \pythonilIdx{for} loops.}%
%
Like conditional statements, \pythonilIdx{for}~loops can be arbitrarily nested.
Let us explore this by computing the list of all prime numbers less than~200 in \cref{lst:loops:for_loop_nested_primes}.%
%
\begin{definition}[Prime Number]%
A prime number~$p\in\naturalNumbersO$ is a positive integer~$p>1$ that has no positive integer divisors other than~$1$ and~$p$ itself~\cite{W2024PN,CP2005PNACP,R1994PNACMFF}.%
\end{definition}%
%
In our example program, we want to store all of these prime numbers in the list\pythonIdx{list} \pythonil{primes}.
We know that \pythonil{2} is a prime number and the only even one, so we directly initialize \pythonil{primes = [2]}, i.e., we set \pythonil{primes} to initially be a list only containing the integer~\pythonil{2}.
This will allow us to later on only consider the odd numbers in the range \intRange{3}{200}.
Just out of interest, we will count the total number of divisions that we need to perform until we have the full list of primes in the variable~\pythonil{n_divisions}.%
%
\begin{sloppypar}%
To find all primes in the integer set~\intRange{2}{200}, we let the loop variable \pythonil{candidate} iterate over~\pythonil{range(3, 200, 2)}\pythonIdx{range}.
This is the sequence of integer numbers starting~\pythonil{3} increasing with step length~\pythonil{2} and stopping right before~\pythonil{200}.
We know that even numbers (except~2) are not prime and we know that 200 is not a prime number either, so this should be OK.
Therefore, \pythonil{candidate} will iteratively become~\pythonil{3}, \pythonil{5}, \pythonil{7}, \dots, and eventually~\pythonil{195}, \pythonil{197}, and \pythonil{199}.
For each value of \pythonil{candidate}, we begin with the assumption that it is prime and then try to prove the opposite.
We set \pythonil{is_prime = True} then will try to find a divisor, in which case we will set \pythonil{is_prime = False}.
If we cannot find a divisor of \pythonil{candidate}, then \pythonil{is_prime} will remain \pythonil{True} and we can add \pythonil{candidate} to the list~\pythonil{primes}.
At least, this is the plan.%
\end{sloppypar}%
%
We will implement this idea with a nested inner loop.
Since the loop variable \pythonil{candidate} will always be odd, only odd numbers can be potential divisors.
Obviously, only integers greater than or equal to~\pythonil{3} are potential divisors.
We also only need to explore whether \pythonil{check} is a divisor of \pythonil{candidate} if it is not bigger than $\sqrt{\pythonil{candidate}}$.
If we had three integer numbers~$a$, $b$, and~$c$ such that $a=b*c$ and $b>\sqrt{a}$, then it must be that $c<\sqrt{a}$.
Since $a=\sqrt{a}*\sqrt{a}$ holds by definition, it would be impossible that $a=b*c$ if both $b>\sqrt{a}$ and $c\geq\sqrt{a}$.
Thus, if $b>\sqrt{a}$ was a divisor of $a$, then $c$ would also be a divisor of~$a$ that we would have found before reaching~$b$ in the loop since~$c<\sqrt{a}<b$.

Now, most integer numbers do not have integer square roots.
Since integer divisors cannot have fractions anyway, it is sufficient for us to use $\left\lfloor\sqrt{\pythonil{candidate}}\right\rfloor$.
In \python, such a \inQuotes{truncated} integer square root of an integer number~$\left\lfloor\sqrt{a}\right\rfloor$ can be computed using the \pythonilIdx{isqrt} function from the \pythonilIdx{math} module, which we \pythonilIdx{import} at the top of our program.

We can therefore iterate a second, inner loop variable \pythonil{check} over \pythonil{range(3, isqrt(candidate) + 1, 2)}\pythonIdx{range}\pythonIdx{isqrt}.
If \pythonil{candidate <= 3}, then this loop will never be executed because no number \pythonil{check} with $3\leq\pythonil{check}<\pythonil{candidate}$ exists.
Then, \pythonil{is_prime} will remain \pythonil{True} and we will add \pythonil{candidate} to \pythonil{primes} further down the outer loop body.
If \pythonil{candidate > 3}, then \pythonil{check} will go from $\pythonil{3}, \dots, \left\lfloor\sqrt{\pythonil{candidate}}\right\rfloor$.

In the body of our inner loop, we try to find out whether \pythonil{check} is an integer divisor of \pythonil{candidate}.
We can do this by computing the remainder of the division~$\pythonil{canddiate}/\pythonil{check}$.
Back in \cref{sec:int:integerArithmetics} we learned the \pgls{modulodiv} operator \expandafter\pythonilIdx{\%}, which does exactly that.
If \pythonil{candidate \% check} is~\pythonil{0}, then we can divide \pythonil{candidate} by \pythonil{check} without remainder.
Then, \pythonil{candidate} is divisible by \pythonil{check} and cannot be a prime number.
We thus can set \pythonil{is_prime = False}.
We can also immediately exit the inner loop using the \pythonilIdx{break} statement, because once we know that \pythonil{candidate} is not a prime number, we do not need to check further potential divisors.
(Notice that we also count all the \pgls{modulodiv} operations we perform by doing \pythonil{n_divisions += 1} at the beginning of the inner loop.)

After the inner loop, if \pythonil{is_prime} is still \pythonil{True}, we add \pythonil{candidate} to \pythonil{primes} by invoking the \pythonilIdx{append}\pythonIdx{list!append} method of the list.
Once we have completed the outer loop as well, we print the number~\pythonil{n_divisions} of divisions we have performed, the number~\pythonil{len(primes)}\pythonIdx{len}\pythonIdx{list!len} of prime numbers we have discovered and, finally, the list~\pythonil{primes} itself.
The output in \cref{exec:loops:for_loop_nested_primes} tells us that, after performing 252~divisions, we could identify 46~prime numbers inside~\intRange{2}{200}.%
%
\FloatBarrier%
\endhsection%
%
\hsection{Loops over Sequences}%
%
\gitPythonAndOutput{\programmingWithPythonCodeRepo}{04_loops}{for_loop_sequence.py}{--args format}{loops:for_loop_sequence}{%
An example iterating over the elements in different collection datastructures using \pythonilIdx{for} loops\pythonIdx{loop!for}.}%
%
When introducing the \pythonilIdx{for} loop\pythonIdx{for}\pythonIdx{loop!for}, we stated that it iterates over sequences of data.
We learned that \pythonilsIdx{range} are the most basic such sequences.
However, in \cref{sec:collections} we learned about collection datatypes, namely \pythonilsIdx{list}, \pythonilsIdx{tuple}, \pythonilsIdx{set}, and \pythonilsIdx{dict}.
The elements of all of these datatypes can be accessed sequentially, too.
This means that a \pythonilIdx{for} loop can iterate over them as well!

In \cref{lst:loops:for_loop_sequence} we illustrate how this is done:
It works exactly as if we were using \pythonilsIdx{range}.
In the program, we will build a list~\pythonil{txt} with strings that we will later write to the output.

First, we want to iterate over a list\pythonIdx{list}~\pythonil{lst} containing the four integers~\pythonil{[1, 2, 3, 50]}.\pythonIdx{list!iterate over}
This is done by simply writing \pythonil{for i in lst}.
Here, \pythonil{i} is the loop variable and it will step-by-step take on all the values in~\pythonil{lst}, one by one.
In the body of this loop, we invoke \pythonil{txt.append(f"i=\{i\}")}.
The \pgls{fstring} will evaluate to \pythonil{"i=1"} in the first iteration, to \pythonil{"i=2"} in the second, to \pythonil{"i=3"} in the third, and to \pythonil{"i=50"} in the fourth and last iteration of this loop.
These strings are appended to the list \pythonil{txt} via the \pythonilIdx{append}\pythonIdx{list!append} method.

Then we move on and want to iterate over a tuple\pythonIdx{tuple}~\pythonil{tp}, which contains three floating point numbers, namely~\pythonil{(7.6, 9.4, 8.1)}.\pythonIdx{tuple!iterate over}
This works exactly in the same way:
\pythonil{for f in tp} will let the loop variable~\pythonil{f} take on the values \pythonil{7.6}, \pythonil{9.4}, and finally~\pythonil{8.1}.
We again append\pythonIdx{list!append}\pythonIdx{append} their textual representation to the list \pythonil{txt}, this time using the \pgls{fstring} \pythonil{f"f=\{f\}"}.

As third example, we create the set\pythonIdx{set}~\pythonil{st} containing the three strings~\pythonil{\{"u", "v", "w"\}}.\pythonIdx{set!iterate over}
We can do this again by simply writing \pythonil{for s in st}, which lets the loop variable~\pythonil{s} take on the values \pythonil{"w"}, \pythonil{"u"}, and \pythonil{"v"}, \emph{in an arbitrary order}.
Remember that sets in \python\ are unordered (see \cref{bp:setsUnordered}), which means that if we run the program twice, we may get different results.
Either way, we can iterate over all the values in the set~\pythonil{st}.
We again want to store these values as nicely formatted strings in~\pythonil{txt}.
This time we use the \pgls{fstring} \pythonil{f"s=\{s!r\}"}.
Notice the \pythonil{!r} format specifier\pythonIdx{!r}:
It will print the \emph{representation} of the string~\pythonil{s}, which basically means to put quotation marks (and to potentially escape\pythonIdx{str!escaping}\pythonIdx{escaping} otherwise unprintable characters, see \cref{sec:str:escaping}).
Thus, we will add \pythonil{"s='v'"}, \pythonil{"s='u'"}, and~\pythonil{"s='w'"} to \pythonil{txt} (in an arbitrary order).

As fourth and final example, we create a dictionary~\pythonil{dc}\pythonIdx{dict} that maps floating point numbers to Boolean values, containing the two entries, namely~\pythonil{\{1.1: True, 2.5: False\}}.\pythonIdx{dict!iterate over}
Now a dictionary is a bit special:
It maps keys to values.
When working with the whole dictionary datastructure~\pythonil{dc} as a collection, then we can access it in three ways:
%
\begin{enumerate}%
%
\item Iterating over \pythonil{dc} directly lets us view all the keys in the dictionary~\pythonil{dc}. %
This is equivalent to iterating over \pythonil{dc.keys()}\pythonIdx{dict!keys}.%
%
\item Iterating over \pythonil{dc.values()}\pythonIdx{dict!values} lets us access all the values in the dictionary~\pythonil{dc}.%
%
\item Iterating over \pythonil{dc.items()}\pythonIdx{dict!items} lets us access all key-value pairs in the dictionary~\pythonil{dc} as tuples.%
\end{enumerate}%
%
In our example program, we apply all of these methods.
We iterate over the keys in~\pythonil{dc} via \pythonil{for k in dc}, which lets \pythonil{k} take on the values \pythonil{1.1} and \pythonil{2.5}, one after the other.
We iterate over the values in~\pythonil{dc} via \pythonil{for v in dc.values()}, which lets \pythonil{v} take on the values \pythonil{True} and \pythonil{False}, one after the other.%
%
\begin{sloppypar}%
Finally, we iterate over all key-value pairs.
Look closely at this one:
We \emph{could} write \pythonil{for t in dc.items()}, which would let a loop variable~\pythonil{t} take on the tuple values \pythonil{(1.1, True)} and then \pythonil{2.5: False}.
However, back in \cref{sec:tuples}, we learned about tuple unpacking\pythonIdx{tuple!unpacking}\pythonIdx{unpacking}.
So instead, we write \pythonil{for k, v in dc.items()}.
This is a shortcut for writing \pythonil{for t in dc.items()} followed by \pythonil{k, v = t}.
It directly unpacks the tuples in the sequence \pythonil{dc.items}, meaning that we get pairs of \pythonil{k=1.1}, \pythonil{v=True} and \pythonil{k=2.5}, \pythonil{v=False}.
All of them are again appended to our text list~\pythonil{txt}.%
\end{sloppypar}%
%
After all of these loops, we have ended up with a list~\pythonil{txt} containing~16 strings.
We want to combine all of them to a single string, using \pythonil{", "} as a separator.
We could do this in another loop.
However, \python\ offers us a much more efficient shorthand for this:
The method \pythonilIdx{join}\pythonIdx{str!join} of the class~\pythonilIdx{str}.

For any string~\pythonil{z}, \pythonil{z.join(seq)} accepts a sequence \pythonil{v} of strings.
It then concatenates all the strings in \pythonil{seq}, placing \pythonil{z} as separator between any two strings.
Thus, invoking \pythonil{", ".join(txt)} produces \textil{i=1, i=2, i=3, i=50, f=7.6, f=9.4, ...}.
This text is finally is written to the output via the \pythonilIdx{print} function, giving us the results shown in  \cref{exec:loops:for_loop_sequence}.

\gitPythonAndOutput{\programmingWithPythonCodeRepo}{04_loops}{for_loop_sequence_primes.py}{--args format}{loops:for_loop_sequence_primes}{%
Computing a list of all primes from \intRange{2}{200} using nested \pythonilIdx{for} loops. %
Compared to \cref{lst:loops:for_loop_nested_primes}, this program is more efficient because it only tests primes as divisors.%
}

Let us now use this new ability to iterate over collection datastructures to improve upon our prime number enumeration program \cref{lst:loops:for_loop_nested_primes}.
Back when writing that program, we immediately stored \pythonil{2} as a prime into our list~\pythonil{primes}.
We then only tried the odd numbers less than~200 as potential prime number \pythonils{candidate}.
For each potential prime number \pythonil{candidate}, we tested all (odd) numbers~\pythonil{check} from the range \pythonil{range(3, isqrt(candidate) + 1, 2)}\pythonIdx{range} as possible divisors.

When thinking about this, we realize that actually, only the prime numbers in this range are interesting.
For example, we do never need to check whether \pythonil{candidate} is divisible by~9, because we will have already checked whether it can be divided by~3.
We also never need to check whether we can divide it by~55, because we will have already checked~5.

Therefore, in our new and more efficient program \cref{lst:loops:for_loop_sequence_primes}, we replace the head of the inner loop with~\pythonil{for check in primes[1:]:}.
\pythonil{primes[1:]} is a slice\pythonIdx{list!slicing}\pythonIdx{slicing}\pythonIdx{slice} of the list~\pythonil{primes} containing all but the first element (see \cref{sec:lists}).
This first element is~\pythonil{2}, and since all \pythonils{candidate} are odd, we do not need to try whether they can be divided by~\pythonil{2}.
The outer loop will step-by-step add prime numbers to \pythonil{primes}.
Actually, for each value of the loop variable \pythonil{candidate}, \pythonil{primes} will contain all prime numbers which are smaller than \pythonil{candidate}.
We only need to check those which are less than or equal to \pythonil{isqrt(candidate)}\pythonIdx{isqrt}, so we store this value in a new variable \pythonil{limit} to avoid re-computing it in the inner loop.
The \pythonilIdx{break} statement lets us exit the inner loop as soon as we hit this limit.

The lists of primes that our programs generate in \cref{exec:loops:for_loop_sequence_primes,exec:loops:for_loop_nested_primes} are exactly the same.
However, our new program needs to perform only 224~divisions instead of~252.%
%
\FloatBarrier%
\endhsection%
%
\hsection{Enumerating over Sequences}%
%
\gitPythonAndOutput{\programmingWithPythonCodeRepo}{04_loops}{for_loop_no_enumerate.py}{--args format}{loops:for_loop_no_enumerate}{%
Enumerating over the index-value pairs of a list (inefficiently).}%
%
Assume that we have a list \pythonil{data} of integer values~\pythonil{v}.
If we want to iterate over all the values~\pythonil{v} in~\pythonil{data}, then \pythonil{for v in data} would do the trick.
However, what if we also want to know the current index~\pythonil{i} for each data element during the iteration?
Then this construct no longer works.

We basically have two choices:
As first option, we can iterate over \pythonil{data} by accessing the elements by their index~\pythonil{i} directly.
In this case, we would use a \pythonilIdx{range} that goes from~\pythonil{0} to \pythonil{len(data) - 1}\pythonIdx{len}\pythonIdx{list!len}.
The head of the loop now looks like this:~\pythonil{for i in range(len(data))}.
The data values~\pythonil{v} are then accessed via~\pythonil{data[i]}.
This is illustrated in \cref{lst:loops:for_loop_no_enumerate}.

The drawback of this method is that it will \emph{only} work for \pythonilsIdx{list}, because among the collection datastructures discussed so far, only \pythonilsIdx{list} are directly indexable.
Therefore, the second option to achieve our goal would be to use an additional integer variable~\pythonil{i} which we would initialize as \pythonil{i: int = 0} before the loop and then increment as~\pythonil{i += 1} at the bottom of the loop body.
This would work with all collection classes.

Both options are a bit iffy, as they introduce more and less readable additional code.
There is a third option, though.
And because I advocate using static code analysis tools, I let another such tool discover this option for us.%
%
\begin{figure}%
\centering%
\includegraphics[width=0.7\linewidth]{\currentDir/pipInstallPylint}%
\caption{Installing \pylint\ in a \ubuntu\ \pgls{terminal} via \pip.}%
\label{fig:pipInstallPylint}%
\end{figure}%
%
\usefulTool{pylint}{%
\pylint\ is a \python\ \pgls{linter} that analyzes code for style, potential errors, and possible improvements~\cite{PC2024PL}. %
It can be installed via \bashil{pip install pylint} as shown in \cref{fig:pipInstallPylint} on \cpageref{fig:pipInstallPylint}. %
You can then apply \pylint\ using the command \bashil{pylint fileToScan.py}. %
We provide a script for using \pylint\ with a reasonable default configuration in \cref{lst:bash:pylint} on \cpageref{lst:bash:pylint}.%
}%
%
\gitOutput{\programmingWithPythonCodeRepo}{.}{scripts/pylint.sh 04_loops for_loop_no_enumerate.py}{loops:for_loop_no_enumerate:pylint}{%
The results of static code analysis using the \pylint\ \pgls{linter} for the program given in \cref{lst:loops:for_loop_no_enumerate}.}%
%
\gitPythonAndOutput{\programmingWithPythonCodeRepo}{04_loops}{for_loop_enumerate.py}{--args format}{loops:for_loop_enumerate}{%
Enumerating over the index-value pairs of a list using the \pythonilIdx{enumerate} function.}%
%
In \cref{exec:loops:for_loop_no_enumerate:pylint}, \pylint\ suggest that we should iterate over the list \pythonil{data} using the \pythonilIdx{enumerate} function.
\pythonilIdx{enumerate} accepts a collection as parameter and creates a sequence of index-value tuples.
Since we can unpack such tuples while iterating over this sequence (see \cref{lst:loops:for_loop_sequence})\pythonIdx{tuple!unpacking}\pythonIdx{unpacking}, the head of our loop now takes on the form \pythonil{for i, v in enumerate(data)}.
Notice that the index~\pythonil{i} comes first and the value~\pythonil{v} comes second in this unpacked-tuple-based enumeration.
This is implemented in \cref{lst:loops:for_loop_enumerate}.
And it would work exactly the same, regardless whether \pythonil{data} was a list, set, tuple, or dictionary.

Now, above we used the \pylint\ \pgls{linter} to discover that we could improve our code by using this concept.
At the time of this writing, \ruff\ and \mypy\ did not find this potential improvement.
Maybe their future versions will.
Regardless, it becomes clear that using more static analysis tools is always a good idea, as stated back in \cref{bp:manyCodeAnalysisTools}.%
%
\endhsection%
%
\endhsection%
%
