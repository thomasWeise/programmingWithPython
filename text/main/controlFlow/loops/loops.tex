\hsection{Loops}%
%
When we are working with sequences of data, we do not just want to perform an action on one data element.
We instead often want to apply the actions repetitively to all data elements.
Loops allow us to do just that, to perform the same actions multiple times.%
\pythonIdx{loop}%
%
\hsection{The \texttt{for} Loop Statement}%
%
\pythonIdx{loop!for}%
The most basic such sequence in \python\ may be the \pythonilIdx{for}~loop, which has the following pattern:%
%
\begin{pythonSyntax}
for loopVariable in sequence:
    loop body statement 1
    loop body statement 2
    # ...

normal statement 1
normal statement 2
# ...
\end{pythonSyntax}
%
%
\gitPythonAndOutput{\programmingWithPythonCodeRepo}{04_loops}{for_loop_range.py}{--args format}{loops:for_loop_range}{%
An example for using the \pythonilIdx{for} loop over a \pythonilsIdx{range} of integer numbers.}%
%
\gitPythonAndOutput{\programmingWithPythonCodeRepo}{04_loops}{for_loop_pi_liu_hui.py}{--args format}{loops:for_loop_pi_liu_hui}{%
A variant of \cref{lst:variables:pi_liu_hui} which uses a \pythonilIdx{for} loop instead of five copies of the same instructions.}%
%
The keyword~\pythonilIdx{for} is followed by a loop variable.
Then comes the keyword~\pythonilIdx{in}, the \pythonil{sequence} we want to iterate over, and finally a colon~(\pythonilIdx{:}).
This variable will iteratively take on the values in the \pythonil{sequence}.
The loop body statements in the following, indented block are executed for each of these values.
Each time the body of the loop is executed is called an~\emph{iteration}\pythonIdx{iteration} of the loop.
After the loop, we leave one blank line followed by the code that will be executed after the loop completes.

In its most simple form, the \pythonilIdx{for} loop is applied to a \pythonilIdx{range} of integer numbers.
Ranges are sequences which work basically like slices\pythonIdx{slice} (see \cref{sec:lists:basicFunctions,sec:strBasicOperations}).
\pythonil{range(5)} will give us a sequence of integers starting with~0 and reaching up to right \emph{before}~5, i.e., the integer range~\intRange{0}{4}.
\pythonil{range(6, 9)} gives the sequence of integers starting with~6 and stopping right \emph{before}~9, i.e., the integer range~\intRange{6}{8}.
Finally, \pythonil{range(20, 27, 2)} results in a sequence of integers that begins at~20, increments by~2 in each step, and ends right before~27.
This is the sequence~$(20, 22, 24, 26)$.
\pythonilsIdx{range}, like slices\pythonIdx{slice}, can also have negative increments:
The \pythonil{range(40, 30, -3)} starts with~40 and stops before reaching~30 and decrements by~3 in each step.
This is equivalent to the set~$(40, 37, 34, 31)$.

In \cref{lst:loops:for_loop_range}, we loop over exactly these ranges.
In this listing, we try to create a dictionary (see \cref{sec:dictionaries}) where some integer numbers are mapped to their squares.
We use four \pythonilIdx{for}~loops to fill this dictionary with data.
In each of these first four \pythonilIdx{for}~loops, we use \pythonil{i} as the loop variable.

When iterating over the \pythonil{range(5)} in the first loop, \pythonil{i} will hold the value \pythonil{0} in the first iteration (=~execution of the loop body).
The loop body \pythonil{squares[i] = i * i} will thus effectively be \pythonil{squares[0] = 0} and thus store the value~\pythonil{0} under key~\pythonil{0} into the dictionary \pythonil{squares}.
In the second iteration, \pythonil{i} will hold the value~\pythonil{1}.
Then, the body \pythonil{squares[i] = i * i} will effectively be \pythonil{squares[1] = 1}.
In the third iteration, \pythonil{i} will hold the value~\pythonil{2} and the body will perform \pythonil{squares[2] = 4}.
Next, \pythonil{i = 3} and \pythonil{squares[3] = 9} will be executed and in the laste iteration of the first loop, we store \pythonil{squares[4] = 16}.

In the second loop, which uses \pythonil{range(6, 9)}, \pythonil{i} will take on the values \pythonil{6}, \pythonil{7}, and \pythonil{8}, one by one.
The dictionary \pythonil{squares} will thus be extended with the values \pythonil{squares[6] = 36}, \pythonil{squares[7] = 49}, and \pythonil{squares[8] = 64}.
In the third loop, iterating over \pythonil{range(20, 27, 2)}, the following updates will be performed one by one \pythonil{squares[20] = 400}, \pythonil{squares[22] = 484}, \pythonil{squares[24] = 576}, and \pythonil{squares[26] = 676}.
In the fourth loop, \pythonil{i} takes on the values of the sequence \pythonil{range(40, 30, -3)}, which has the negative step length~\pythonil{-3}.
\pythonil{i} therefore first becomes~\pythonil{40}, then \pythonil{37} in the second iteration, then \pythonil{34}, and, finally,~\pythonil{31}.
We then print\pythonIdx{print} the dictionary and get the expected output in \cref{exec:loops:for_loop_range}.%
%
\bestPractice{underscore}{%
If we do not care about the value of a variable (or parameter), we should name it~\pythonil{_}\pythonIdx{\_}~\cite{PEP635}. %
This information is useful for other programmers as well as static code analysis tools.%
}%
%
At the end of \cref{lst:loops:for_loop_range} we show this special case:
We want to print\pythonIdx{print} \pythonil{"Hello World!"} three times.
Instead of copying the line \pythonil{print("Hello World!")} three times, we put it in a loop.
However, nowhere in the loop body we care about the value of the loop variable.
We thus simply call it \pythonil{_}\pythonIdx{\_}.
If we would not call it that, then another programmer seeing our code (or a static code analysis tool for that matter) could be confused as to why we do not use the loop variable.
Always remember that \inQuotes{real} code could be much more complicated, and any semantic hint we can include to convey our intentions will be helpful.

With these new tools at hand, we can revisit our old program \cref{lst:variables:pi_liu_hui} to approximate~$\pi$ from back in \cref{sec:approximatePiLiuHui}
In this program, we executed the same code five times.
Instead of doing this, we can put this into a loop, which reduces the lines of code from over~25 to about~10 in \cref{lst:loops:for_loop_pi_liu_hui}.
The outputs in \cref{exec:variables:pi_liu_hui,exec:loops:for_loop_pi_liu_hui} are exactly the same.%
%
\endhsection%
%
\hsection{The \texttt{continue} and \texttt{break} Statements}%
%
\gitPythonAndOutput{\programmingWithPythonCodeRepo}{04_loops}{for_loop_continue_break.py}{--args format}{loops:for_loop_continue_break}{%
An example for the \pythonilIdx{continue} and \pythonilIdx{break} statements in a \pythonilIdx{for} loop.}%
%
Loops often have complex bodies, maybe containing conditional statements or other loops.
It is not an uncommon situation that, after performing some computations in the body of the loop, we already know that we can continue directly with the next iteration instead of executing the remainder of the loop body.
Sometimes we also find that we can entirely stop with the loop and continue with whatever instructions come after it, even if we did not yet exhaust the sequence over which we are iterating.
The former can be achieved using the \pythonilIdx{continue} and the latter with the \pythonilIdx{break} statement.

An example for both statements is given in \cref{lst:loops:for_loop_continue_break}.
Here, we iterate the variable~\pythonil{i} over the 15~values from~\pythonil{0} to~\pythonil{14}.
In the loop body, we first create a string~\pythonil{s} with the current value of~\pythonil{i} via the \pgls{fstring} \pythonil{f"i is now \{i\}."}
The very last instruction of the loop body, \pythonil{print(s)}\pythonIdx{print}, prints this string.

While \pythonil{i} would go from~\pythonil{0} to~\pythonil{14}, we actually want to abort the loop as soon as \pythonil{i} becomes greater than~\pythonil{10}.
Instead of modifying the \pythonilIdx{range} over which we loop (which would be reasonable), we here want to use the \pythonilIdx{break} statement.
We therefore wrap it into the conditional \pythonil{if i > 10:}, meaning that it will only be executed if~\pythonil{i > 10}.
As soon as \pythonilIdx{break} is reached, the loop will immediately be aborted.
No further instruction in the loop body is executed and no further iteration is performed.
Instead, the process will continue after the loop, with the line~\pythonil{print("All done.")}.

If \pythonil{i > 10} did not hold, the rest of the loop body is executed.
For the case that $\pythonil{i}\in\intRange{5}{8}$, we now want to directly jump to the next loop iteration by invoking the \pythonilIdx{continue}~statement.
This means that if \pythonil{i == 5}, the \pythonilIdx{continue}~statement lets the control directly return to the head of the loop, which will set~\pythonil{i = 6}.
This will happen until~\pythonil{i == 9}.
The condition \pythonil{5 <= i <= 8} is \emph{not} met for all $\pythonil{i}\in\intRange{0}{4}\cup\intRange{9}{15}$.
The next line, namely the \pythonil{print(s)}\pythonIdx{print}, can only be reached in these cases.
Of course, we already know that we will never even reach this code as soon as \pythonil{i == 11}.

As a result the program will print the string~\pythonil{s} only for~$\pythonil{i}\in\intRange{0}{4}\cup\{9, 10\}$ before finally outputting~\textil{All done.}.
This can be observed in the program output collected in \cref{exec:loops:for_loop_continue_break}.
With \pythonilIdx{break} and \pythonilIdx{continue}, we now have two tools that can help us to either abort any loop prematurely or to abort the current iteration of the loop prematurely (and continue with the next one, if any), respectively.%
%
\endhsection%
%
\endhsection%
%
