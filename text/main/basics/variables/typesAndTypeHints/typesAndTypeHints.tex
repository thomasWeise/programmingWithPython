\hsection{Variable Types and Type Hints}%
%
\hsection{Variable Types}%
\gitPythonAndOutput{\programmingWithPythonCodeRepo}{01_variables}{variable_types.py}{--args format}{variables:types}{%
An example for the types of variables.}%
%
A variable is basically a name pointing to an object.
Each object has a type and we already learned about several of these datatypes in \cref{sec:simplyDataTypesAndOperations}.
We can obtain the type of an object stored in variable \pythonil{var} by invoking \pythonil{type(var)}\pythonIdx{type}.
\Cref{lst:variables:types} shows a program that does just that and the output of that program is given in \cref{lst:variables:types}.
It is obvious that the type of a variable that holds an integer value is \pythonilIdx{int}, the type of a variable that holds a floating point number is \pythonilIdx{float}, and so on.
There really is not much to say about that.%
\endhsection%
%
\hsection{Types and Confusion}%
\gitPythonAndOutput{\programmingWithPythonCodeRepo}{01_variables}{variable_types_wrong.py}{--args format}{variables:types_wrong}{%
An example for the confusing variable types.}

Well, actually, there is.
You see, when you declare a variable in a language like \texttt{C}, you have to specify its \emph{type}.
You are then permitted to only assign values that have exactly this type to the variable.
In \python, you do not need to specify a type and you can assign whatever you want to a variable.
This has the advantage that the code is shorter (because you do not need to write the type), looks more elegant, and programming becomes easier.
At first glance.
However, there are also problems.
Let's take a look at \cref{lst:variables:types_wrong}.
We declare a variable named \pythonil{int_var} and store the integer~\pythonil{8} in it.
Then we update \pythonil{int_var} by computing \pythonil{int_var = int_var / 3}.
Back in \cref{sec:int}, you learned that the \pythonilIdx{//} operator performs an integer division with an \pythonil{int} result, whereas the division using the \pythonilIdx{/} operator always returns a \pythonil{float}.
This means that our variable \pythonil{int_var} now contains a \pythonil{float}, which is also visible in the output in \cref{exec:variables:types_wrong}.

From the perspective of \python, this is totally fine.
The program executes and the output appears without error.
However, from the perspective of programming, \cref{lst:variables:types_wrong} is \emph{wrong}.
Imagine that this was not just some random example without meaning.
Imagine that this was a part of a really useful program.
Imagine that you got this program from some source and try to understand it.
If you read this program, then you find that a variable named \pythonil{int_var} contains a \pythonil{float}.
This is not forbidden, but when reading the code, it must strike you as odd.

Indeed, there are at least two possible explanations for this:
Either, the original author of this code mistakenly mixed up the \pythonilIdx{/} operator for the \pythonilIdx{//}.
Maybe they wanted to do an integer division and accidentally did a floating point division.
Depending on what the code later on (in our imaginary larger program) does, it could be very hard to find such an error.

Or maybe the author fully well wanted to do a floating point division and expected a \pythonil{float} to be stored in \pythonil{int_var}, but chose a misleading name.
Choosing this name, however, can be very dangerous:
What if another programmer continues to work on this code and, based on the variable's name, expects it to contain an \pythonil{int} whereas it actually contains a \pythonil{float}.
This could again lead to all sorts of strange errors later on in her code.

Regardless of what is true, you will certainly agree that something is wrong with this program.
And since you are not the author of the program, you do not know what is wrong.
This code will cause some problem down the line.
Many such problems exist in many software projects and they indeed are hard to find~\cite{KCVM2022AESOTRDIPP}.
So here, the lenience of \python\ of allowing us to not specify types comes back to bite us.

Luckily, there are two things that we can do to prevent such situations:%
\begin{enumerate}%
\item Use static type checking tools to find such potential errors in our code.%
\item Use type hints to annotate variables with their types.%
\end{enumerate}%
And if you are in one of my classes, you better do both.
And now we will learn how to do that.%
\endhsection%
%
\hsection{Static Type Checking}%
\gitOutput{\programmingWithPythonCodeRepo}{.}{scripts/mypy.sh 01_variables variable_types_wrong.py}{variables:variable_types_wrong:mypy}{%
The static type checking results of the program given in \cref{lst:variables:types_wrong}.}%
\gitOutput{\programmingWithPythonCodeRepo}{.}{scripts/mypy.sh 01_variables variable_types.py}{variables:variable_types:mypy}{%
The static type checking results of the program given in \cref{lst:variables:types}.}%
%
\endhsection%
\FloatBarrier%
\endhsection%
%
