\hsection{Collections}%
\label{sec:collections}%
%
We already learned about simple datatypes, like integer and floating point numbers, strings, and Boolean values.
We also learned how we can use variables to store instances (objects) of such datatypes.
However, in many cases, we do not just want to store a single object.
Often, we want to store and process \emph{collections} of objects~\cite{PSF:P3D:TPSL:BIT,PSF:P3D:TPLR:DM,PSF:P3D:TPSL:CAABCFC}.
\python\ offers us four basic types of collections:

The first one, \emph{lists}, are mutable sequences of objects.
We can create a list \pythonil{my_list} composed of the three strings \pythonil{"a"}, \pythonil{"b"}, and~\pythonil{"c"} by writing \pythonil{my_list = ["a", "b", "c"]}.
Like the characters in strings, we can access the elements of lists using square brackets.
For instance, \pythonil{my_list[0]} would return the first element of \pythonil{my_list}, namely~\pythonil{"a"}.
In \cref{sec:lists} we learn more about lists and we also get to know a new static code analysis tool that can help us to detect programming issues.

The second type of collections is formed by \emph{tuples}.
Tuples are similar to lists, with two main differences:
First, tuples are immutable, which means once a tuple is created, it cannot be changed anymore.
Second, the semantics of tuples allows for them to contain objects of different types, whereas lists should only contain elements of a single type.
Tuples are created using parentheses, so \pythonil{my_tuple = (1, 2, "z")} creates a tuple \pythonil{my_tuple} containing the two integers~\pythonil{1} and~\pythonil{2} as well as the string~\pythonil{z}.
The elements can be accessed using square brackets, so \pythonil{my_tuple[1]} gives us the second element, namely~\pythonil{2}.
We learn more about tuples in \cref{sec:tuples}.

The mathematical notion of sets is implemented in the \python\ datatype \pythonil{set}.
A set can contain each element at most once.
The methods for modifying sets and for checking whether elements are contained in them are particularly fast.
Sets are created using curly braces, i.e., \pythonil{my_set = \{1.2, 2.3, 4.5, 2.3\}}\pythonIdx{\textbraceleft\idxdots\textbraceright!set} would create the set \pythonil{my_set} with the three numbers \pythonil{1.2}, \pythonil{2.3}, and~\pythonil{4.5}.
Notice that \pythonil{2.3} would appear only once in the set.
Sets cannot be indexed, but like lists and tuples they support the \pythonil{in} operator and \pythonil{1.2 in my_set} returns \pythonil{True} while \pythonil{1.3 in my_set} is \pythonil{False}.
We will discuss sets in \cref{sec:sets}.

Finally, dictionaries are mappings between keys and values, similar to hash tables in other programming languages.
They, too, are created using curly braces which, however, contain key-value pairs.
In other words, \pythonil{my_dict = \{"pi": 3.1416, "e": 2.7183, "phi": 1.618\}}\pythonIdx{\textbraceleft\idxdots\textbraceright!dict} creates a dictionary which maps the strings \pythonil{"pi"}, \pythonil{"e"}, and \pythonil{"phi"} to the values \pythonil{3.1416}, \pythonil{2.7183}, and~\pythonil{1.618}, respectively.
The value of a key can be retrieved using the square-bracket indexing, i.e., \pythonil{my_dict["e"]} would return \pythonil{2.7183}.
They are discussed in \cref{sec:dictionaries}.%
%
%
\hinput{lists}{lists.tex}%
\hinput{tuples}{tuples.tex}%
\hinput{sets}{sets.tex}%
\hinput{dictionaries}{dictionaries.tex}%
\hinput{summary}{summary.tex}%
%
\endhsection%
%
