\hsection{Text Strings}%
\label{sec:str}%
%
The fourth important datatype in \python\ are text strings.
Text strings are sequences of characters of an arbitrary length.
In \python, they are represented by the datatype \pythonilIdx{str}.
Indeed, we have already used it before, even in our very first example program back that simply printed \pythonil{"Hello World"} in \cref{lst:very_first_program} in \cref{sec:ourFirstProgram}.
\pythonil{"Hello World"} is such a text string.%
%
\hsection{Basic String Operations}%
%
\begin{figure}%
\centering%
\includegraphics[width=0.8\linewidth]{\currentDir/strIndexing}%
\caption{Specifying string literals and indexing its characters.}%
\label{fig:strIndexing}%
\end{figure}%
%
As \cref{fig:strIndexing} shows, there are two basic ways to specify a text string literal\pythonIdx{str!literal}:
Either enclosed by double quotes, e.g., \pythonil{"Hello World!"}\pythonIdx{\textquotedbl} or enclosed by single quotes, e.g., \pythonil{'Hello World!'}\pythonIdx{\textquotesingle}.
The double-quote variant is usually preferred and we should always use it in our programs.
The quotation marks are only used to delimit the strings, i.e., to tell \python\ where the string begins or ends.
They are not themselves part of the string.

One basic operation is string concatenation\pythonIdx{str!concatenation}\pythonIdx{str!+}\pythonIdx{+}:
\pythonil{"Hello" + ' ' + "World"}\pythonIdx{\textquotedbl}\pythonIdx{\textquotesingle} concatenates the three strings \pythonil{"Hello"}, \pythonil{" "}, and \pythonil{"World"}.
The result is \pythonil{"Hello World"}\pythonIdx{\textquotedbl}.
Notice how the singe space character string is needed, because \pythonil{"Hello" + "World"} would just yield \pythonil{"HelloWorld"}.

Strings are different from the other datatypes we have seen so far.
They are \emph{sequences}\pythonIdx{Sequence}, meaning that they are linear arrays composed of elements.
These elements are the single characters, which correspond to letters, numbers, punctuation marks, white space, etc.

One basic set of things that we can do with strings is to extract these single characters.
First, we need to know the length of a string.
For this purpose, we can invoke the \pythonilIdx{len}\pythonIdx{str!len}\pythonIdx{str!length} function:
\pythonil{len("Hello")} is \pythonil{5}, because there are five characters in \inQuotes{Hello}.
\pythonil{len("Hello World!")} would give us \pythonil{12}, because \pythonil{"Hello"} has five characters, \pythonil{"World!"} has six characters (the \pythonil{"!"} does count!) and there is the single space character in the middle, so $5+6+1=12$.

Knowing the length\pythonIdx{str!length} of a string, we can now safely access its single characters.
These characters are obtained using the square brackets \pythonil{[]}\pythonIdx{str![]}\pythonIdx{[}\pythonIdx{]} with the character index inbetween.
The character indexes start at~0.
Therefore, \pythonil{"Hello"[0]}\pythonIdx{str![]}\pythonIdx{[}\pythonIdx{]} returns the first character of \pythonil{"Hello"} as a \pythonilIdx{str}, which is \pythonil{"H"}\pythonIdx{\textquotedbl}.
\pythonil{"Hello"[1]} returns the second character, which is \pythonil{"e"}.
\pythonil{"Hello"[2]} returns the third character, which is \pythonil{"l"}.
\pythonil{"Hello"[3]}\pythonIdx{str![]}\pythonIdx{[}\pythonIdx{]} gives us the second \pythonil{"l"}.
Finally, \pythonil{"Hello"[4]} gives us the fifth and last character, namely \pythonil{"o"}\pythonIdx{\textquotedbl}.
If we would try to access a character outside of the valid range of the string, say \pythonil{"Hello"[5]}, this results in an \pythonilIdx{IndexError}.
We learn later what errors are and how to handle them -- for now, it is sufficient to know that they will stop your program.
And rightly so, because \pythonil{"Hello"}\pythonIdx{\textquotedbl} has only five characters and accessing the sixth one is not possible and would have an undefined result.

Negative indices, however, are permitted:
The index \pythonil{-1} just means \inQuotes{last character}, so \pythonil{"Hello"[-1]} yields the string \pythonil{"o"}.
The index \pythonil{-2} then refers to the \inQuotes{second-to-last character}, so \pythonil{"Hello"[-2]} gives us \pythonil{"l"}.
The third character from the end, accessed via index \pythonil{-3}, is again \pythonil{"l"}.
\pythonil{"Hello"[-4]} gives us \pythonil{"e"} and \pythonil{"Hello"[-5]} gives us \pythonil{"H"}.
Of course, using a negative index that would bring us out of the string's valid range, such as \pythonil{-6}, again yields an \pythonilIdx{IndexError}.

We can also obtain whole substrings by using index ranges, where the inclusive starting index and the \emph{exclusive} end index are separated by a~\pythonilIdx{:}.
In other words, applying the index \pythonil{[a:b]} to a string results in all characters in the index range from \pythonil{a} to \pythonil{b - 1}.
\pythonil{"Hello"[0:3]} yields a string composed of the characters at positions~0, 1, and~2 inside \pythonil{"Hello"}, i.e., \pythonil{"Hel"}.
The end index is always excluded, so the character at index~3 is not part of the result.
If we do \pythonil{"Hello"[1:3]}, we get \pythonil{"He"}, because only the characters at indices~1 and~2 are included.
If we do not specify an end index, then everything starting at the start index until the end of the string is included.
This means that \pythonil{"Hello"[2:]} will return all the text starting at index~2, which is \pythonil{"llo"}.
We can also use negative indices, if we want.
Therefore, \pythonil{"Hello"[1:-2]} yields \pythonil{"el"}
Finally, we can also omit the start index, in which case everything until right before the end index is returned.
Therefore, \pythonil{"Hello"[:-2]} will return everything from the beginning of the string until right before the second-to-last character.
This gives us \pythonil{"Hel"}.

\begin{figure}%
\centering%
\includegraphics[width=0.8\linewidth]{\currentDir/strBasicOps}%
\caption{Some more basic string operations.}%
\label{fig:strBasicOps}%
\end{figure}%

Besides concatenating and extracting substrings, the \pythonilIdx{str} datatype supports many other operations.
Here, we can just discuss the few most commonly used ones.

There are several ways to check whether one string is contained in another one.
The first method is to use the \pythonilIdx{in} keyword.
As \cref{fig:strBasicOps} shows, \pythonil{"World" in "Hello World!"} yields \pythonilIdx{True}, as it checks whether \pythonil{"World"} is contained in \pythonil{"Hello World!"}, which is indeed the case.
\pythonil{"Earth" in "Hello World!"} is \pythonilIdx{False}, because \pythonil{"Earth"} is not contained in \pythonil{"Hello World!"}.

Often, however, we do not just want to know whether a string is contained in another one, but also \emph{where} it is contained.
For this, the \pythonilIdx{find} method exists.
\pythonil{"Hello World!".find("World")} tries to find the position of \pythonil{"World"} inside \pythonil{"Hello World!"}.
It returns \pythonil{6}, because the \inQuotes{W} of \inQuotes{World} is the seventh character in this string and the indices are zero-based.
Trying to find the \pythonil{"world"} in \pythonil{"Hello World!"} yields~\pythonil{-1}, however.
\pythonil{-1} means that the string cannot be found.
We learn that string operations are case-sensitive\pythonIdx{str!case-sensitive}:
\pythonil{"World" != "world"} would be \pythonilIdx{True}.
We also learn that we need to be careful not to use the result of \pythonilIdx{find} as index in a string directly before checking that it is \pythonil{>= 0}!
As you have learned, \pythonil{-1} is a perfectly fine index into a string, even though it means that the string we tried to find was not found.

Sometimes, the text we are looking for is contained multiple times in a given string.
For example, \pythonil{"Hello World!".find("l")} returns~\pythonil{2}, because \inQuotes{l} is the third character in the string.
However, it is also the fourth character in the string.
\pythonilIdx{find} accepts an optional second parameter, namely the starting index where the search should begin.
\pythonil{"Hello World!".find("l", 3)} begins to search for \pythonil{"l"} inside \pythonil{"Hello World!"} starting at index~3.
Right at that index, the second~\inQuotes{l} is found, so that \pythonil{3} is also returned.
If we search for another~\inQuotes{l} after that, we would do \pythonil{"Hello World!".find("l", 4)}, which returns index~9, identifying the~\inQuotes{l} in~\inQuotes{World}.
After that, no more~\inQuotes{l} can be found in the string, so \pythonil{"Hello World!".find("l", 10)} results in a~\pythonil{-1}.%
%
\begin{sloppypar}%
While \pythonilIdx{find} returns the first occurrence of a string in the supplied range, we sometimes want the last occurrence instead.
If we want to search from the end of the string, we use \pythonilIdx{rfind}.
\pythonil{"Hello World!".rfind("l")} gives us~\pythonil{9} directly.
If we want to search for the~\inQuotes{l} before that one, we need to supply an inclusive starting and exclusive ending index of the range to be searched.
\pythonil{"Hello World!".rfind("l", 0, 9)} searches for any~\inQuotes{l} from index~8 down to~0 and thus returns~\pythonil{3}.
\pythonil{"Hello World!".rfind("l", 0, 3)} gives us~\pythonil{2} and since there is no~\inQuotes{l} before that, \pythonil{"Hello World!".rfind("l", 0, 2)} yields~\pythonil{-1}.
\end{sloppypar}%
%
\begin{sloppypar}%
Another common operation is to replace substrings with something else.
\pythonil{"Hello World!".replace("Hello", "Hi")}\pythonIdx{replace} replaces all occurrences of \inQuotes{"Hello"} in \inQuotes{Hello World} with \inQuotes{Hi}.
The result is \pythonil{"Hi World!"} and \pythonil{"Hello Hello World!".replace("Hello", "Hi")} becomes \pythonil{"Hi Hi World!"}.
\end{sloppypar}%
%
\begin{sloppypar}%
Often, we want to remove all leading or trailing whitespace characters from a string.
The \pythonilIdx{strip} function does this for us:
\pythonil{" Hello World! ".strip()} returns \pythonil{"Hello World!".strip()}, i.e., the same string, but with the leading and trailing space removed.
If we only want to remove the spaces on the left-hand side, we use \pythonilIdx{lstrip} and if we only want to remove those on the right-hand side, we use \pythonilIdx{rstrip} instead.
Therefore, \pythonil{" Hello World! ".lstrip()} yields \pythonil{"Hello World! "} and \pythonil{" Hello World! ".rstrip()} gives us \pythonil{" Hello World!"}.
\end{sloppypar}%
%
In alphabet-based languages, we usually can distinguish between uppercase\pythonIdx{str!uppercase} characters, such as \inQuotes{H} and \inQuotes{W}, and lowercase\pythonIdx{str!lowercase}, such as \inQuotes{e}, \inQuotes{l}, and~\inQuotes{o}.
The method \pythonilIdx{lower} transforms all characters in a string to lowercase and \pythonilIdx{upper} translates them to uppercase instead.
Thus \pythonil{"Hello World!".lower()} returns \pythonil{hello world!} whereas \pythonil{"Hello World!".upper()} yields \pythonil{"HELLO WORLD!"}.

As final functions, we can check whether a string begins or ends with another, we can use \pythonilIdx{startswith} and \pythonilIdx{endswith}, respectively.
\pythonil{"Hello World!".startswith("hello")} is \pythonilIdx{False} whereas \pythonil{"Hello World!".startswith("Hello")} is \pythonilIdx{True}.
\pythonil{"Hello World!".endswith("Hello")} is \pythonilIdx{False}, too, but \pythonil{"Hello World!".endswith("World!")} is \pythonilIdx{True}.

Of course, these were just a small selection of the many string operations available in \python.
You can find more in the \href{https://docs.python.org/3/library/stdtypes.html\#textseq}{official documentation}~\cite{PSF2024TSTS}.%
\endhsection%
%
\hsection{f-strings}%
%
\begin{figure}%
\centering%
\includegraphics[width=0.8\linewidth]{\currentDir/fstrings}%
\caption{\python\ f-strings in action.}%
\label{fig:fstrings}%
\end{figure}%
%
Let us now discuss, preliminary, a very powerful gadget in \python's string processing toolbox: format strings, or f\nobreakdash-strings\pythonIdx{f-strings}\pythonIdx{str!f} for short~\cite{PSF2024FSL,S2016P4LSI,M2017WAFSIPAHCIUT,B2023PFS}.
An f-string is like a normal string, except that it starts with \pythonil{f"}\pythonIdx{f\textquotedbl} instead of \pythonil{"}.
And, most importantly, it can contain other data and even complete expressions inside curly braces (\pythonil{\{...\}}\pythonIdx{\textbraceleft}\pythonIdx{\textbraceright}) which are then embedded into the string.%
%
\begin{sloppypar}%
In \cref{fig:fstrings}, we first consider the f-string \pythonil{f"\{12345678901234\}\ is a really big integer."}\footnote{
The code that formats my inline \python\ examples sometimes eats spaces after \textbraceleft\ or \textbraceright. %
Therefore, some of the strings presented here may look a bit off. %
In \cref{fig:fstrings}, they are printed correctly, though.}.
This is basically a normal string, except that it contains an integer value.
The opening curly brace~(\inQuotes{\textbraceleft}) right at its beginning signifies that some \python\ expression will begin which must be translated to a string.
The actual expression, \pythonil{12345678901234} is just a really big integer.
The closing curly brace~(\inQuotes{\textbraceright}) signifies the end of the expression.
The \python\ interpreter evaluates all expressions inside such curly braces inside the f-string and then turns their results to strings (and removes the curly braces).
\pythonil{f"\{12345678901234\}\ is a really big integer."} simply becomes \pythonil{f"12345678901234 is a really big integer."}%
\end{sloppypar}%
%
\begin{sloppypar}%
This first example was not very spectacular.
But we f-string offer us several interesting means to format data.
For example, we can add some formatting specifiers after the expression, separated by~\pythonilIdx{:}.
If our expression evaluates to an \pythonilIdx{int}, then we can specify a \inQuotes{thousand separator} after the~\pythonilIdx{:}.
In western languages, it is usually to group the digits of large numbers in groups of~3.
In Chinese, they tend to use groups of~4 instead.
To the best of my knowledge, we can only specify thousand separators, thought.
This separator will be placed every three digits in the generated text.
As example, \pythonil{f"12345678901234 with thousand separator ',' is \{12345678901234:,\}."} turns into \pythonil{"12345678901234 with thousand separator ',' is 12,345,678,901,234."}.%
\end{sloppypar}%
%
\begin{sloppypar}%
Back in \cref{sec:int:bitstrings}, we learned that integers can also be represented in hexadecimal and binary format.
f-strings conveniently offer this out-of-the-box, we just need to add a~\pythonilIdx{:x} or a~\pythonilIdx{:b} format specifier to the expression, respectively.
For example, the f-string \pythonil{f"\{12345678901234\}\ in hexadecimal notation is \{12345678901234:x\}."} becomes \pythonil{"12345678901234 in hexadecimal notation is b3a73ce2ff2."} and the f-string \pythonil{f"\{1234567890\}\ in binary notation is \{1234567890:b\}."} is turned to \pythonil{"1234567890 in binary notation is 1001001100101100000001011010010."}.
We can also add the \pythonilIdx{0x} and \pythonilIdx{0b} prefixes to the generated number strings by using the \pythonilIdx{:\#x} and \pythonilIdx{:\#b} format specifiers instead.
Let us use the same examples again but instead with the \#-prefixes in the format specifiers.
The hexadecimal variant \pythonil{f"\{12345678901234\}\ in 0x-hexadecimal notation is \{12345678901234:\#x\}."} then becomes \pythonil{"12345678901234 in 0x-hexadecimal notation is 0xb3a73ce2ff2."}.
The binary formatting string \pythonil{f"\{1234567890\}\ in 0b-binary notation is \{1234567890:#b\}."} turns into \pythonil{"1234567890 in 0b-binary notation is 0b1001001100101100000001011010010."}.%
\end{sloppypar}%
%
\begin{sloppypar}%
But f-strings allow us to do even more.
They can contain complete \python\ expressions.
\pythonil{f"\{5\}\ + \{4\}\ = \{5 + 4\}"} is evaluated to \pythonil{"5 + 4 = 9"}.%
\end{sloppypar}%
%
\begin{sloppypar}%
We can also access constants and variables from within the f-string.
Let us again import the constant~$\pi$ from the \pythonilIdx{math} module by doing \pythonil{from math import pi}\pythonIdx{from}\pythonIdx{math}\pythonIdx{import}\pythonIdx{pi}.
We can print it as string by typing \pythonil{f"pi is approximately \{pi\}."} into the \python\ console.
The result is the string \pythonil{"pi is approximately 3.141592653589793."}%
\end{sloppypar}%
%
\begin{sloppypar}%
In many situations, we do not want to see the full \pythonilIdx{float} value with all available significant digits.
We can round it to two decimals by adding the \pythonilIdx{.2f} format specifier.
Three digits would be \pythonilIdx{.3f} and so on{\dots}
Anyway, \pythonil{f"pi rounded to two decimals is \{pi:.2f\}."} gives us \pythonil{"pi rounded to two decimals is 3.14."}.%
\end{sloppypar}%
%
\begin{sloppypar}%
Sometimes, we want to present a floating point value as a percentage.
For example, $\frac{1}{321}=0.003115265\approx0.31\%$.
How can we convert such value to a nice string?
By using the \pythonilIdx{:.2\%} format specifier, which gives us a percentage with two decimals.
\pythonilIdx{:.4\%} would yield three decimals, and so on{\dots}
Therefore \pythonil{f"1/321 as percentage with 2 decimals is \{1/321:.2\%\}."} turns into \pythonil{"1/321 as percentage with 2 decimals is 0.31\%."}.%
\end{sloppypar}%
%
\begin{sloppypar}%
We can also combine thousand separators and rounding to decimals.
The format specifier \pythonilIdx{,.1f} will use the comma~\inQuotes{,} as thousand separator and print a floating point number rounded to one decimal.
The f-string \pythonil{f"1.2345533e6 with thousand separator and 1 decimal is \{1.2345533e6:,.1f\}."} thus is evaluated to \pythonil{"1.2345533e6 with thousand separator and 1 decimal is 1,234,553.3."}.%
\end{sloppypar}%
%
\begin{sloppypar}%
Let us also insert a floating point arithmetic expression in an f-string.
We therefore import the sine function \pythonilIdx{sin} from the \pythonilIdx{math} module via \pythonil{from math import sin}\pythonIdx{from}\pythonIdx{math}\pythonIdx{import}\pythonIdx{sin}.
The f-string \pythonil{f"sin(0.25pi) is approximately \{sin(0.25*pi):.5f\}."} computes the expression \pythonil{sin(0.25*pi)} and presents its result rounded to five decimals via the \pythonilIdx{:.5f} format specifier.
It therefore becomes \pythonil{"sin(0.25pi) is approximately 0.70711."}.%
\end{sloppypar}%
%
\begin{sloppypar}%
We can also use the scientific notation.
The format speciier \pythonilIdx{:e} simply prints a number in scientific notation back from \cref{sec:scientificNotation}.
\pythonilIdx{:.3g} uses scientific notation, but only presents three digits, whereas \pythonilIdx{:.4g} would present four digits, and so on{\dots}
\pythonil{f"\{1.2359817e12\}\ is \{1.2359817e12:e\}\ and approximately \{1.2359817e12:.3g\}."} prints the same number three times.
First, it is simply rendered as normal \pythonilIdx{float} value, then it is rendered in scientific notation, and then it is rendered in scientific notation, but rounded to three digits.
This gives us \pythonil{"235981700000.0 is 1.235982e+12 and approximately 1.24e+12."}.%
\end{sloppypar}%
%
The keen reader may have encountered a question at this stage:
\emph{\inQuotes{What do I do if I want to include a curly brace, say \textbraceleft\ or \textbraceright\ inside my f-string?}}
Well, if you include a single brace, it would be interpreted as start or end of an expression.
If the following text makes sense as expression, it will be interpreted.
If not, an error will occur.
Either way, the curly brace would disappear.
The solution is simple:
If you need \inQuotes{\textbraceleft}, just write \inQuotes{\textbraceleft\textbraceleft}.\pythonIdx{\textbraceleft}\pythonIdx{\textbraceleft\textbraceleft}
It will be interpreted as a single \inQuotes{\textbraceleft}~brace.
If you need \inQuotes{\textbraceright}, just write \inQuotes{\textbraceright\textbraceright}.\pythonIdx{\textbraceright}\pythonIdx{\textbraceright\textbraceright}
It will be interpreted as a single \inQuotes{\textbraceright}~brace.
\pythonil{f"Single braces without expression: \{\{ and \}\}."} simply becomes \pythonil{"Single braces without expression: \{ and \}."}

You are now able to convert the results of your computations to nice text.%
\endhsection%
%
\hsection{Escaping Characters}%
%
\begin{figure}%
\centering%
\includegraphics[width=0.8\linewidth]{\currentDir/strEscapes}%
\caption{Escaping special characters in \python\ strings.}%
\label{fig:strEscapes}%
\end{figure}%
%
The last example of f-strings brought up an interesting topic:
\inQuotes{What do we do if we want to use a character in a string which we cannot use?}
For example, if our string is delimited with double quotation marks~\pythonil{"}\pythonIdx{\textquotedbl}, then we cannot put the character \inQuotes{\pythonil{"}} into it, because it would then be interpreted as the end of the string.
On the other hand, if our string is delimited with single quotation marks~\pythonil{'}\pythonIdx{\textquotesingle}, then we cannot put the character \inQuotes{\pythonil{'}} into it, because it would then be interpreted as the end of the string.
Well, you can say, if I need a double quotation mark, then I will delimit my string with single quotation marks and vice versa.
This is all good as long as you do not need \emph{both} single and double quotation marks inside the string.

The answer to this problem is \emph{escaping}\pythonIdx{str!escaping}.
The idea is very simple:
If we need a certain quotation mark, then we simply put a backslash~(\inQuotes{\textbackslash})\pythonIdx{\textbackslash} before it.
The backslash tells the \python\ interpreter that the next character should be considered as a normal character and not be interpreted as any special character, like a string delimiter.

In \cref{fig:strEscapes}, we present several strings with escape sequences.
For clarity reasons, we pass them to the \pythonilIdx{print} function to output them, which means that they show up undelimited in the console.
A double quotation mark can be printed as \pythonil{print("\\"")}, i.e., as a string which is delimited and that then contains the escape sequence {\textbackslash\textquotedbl}\pythonIdx{\textbackslash\textquotedbl}.
It then shows up as~\inlinelistingbox{\texttt{"}} in the output.
A single quotation mark can be printed as \pythonil{print("\\'")}, i.e., via the escape sequence {\textbackslash\textquotesingle}\pythonIdx{\textbackslash\textquotesingle}.
It appears as~\inlinelistingbox{\texttt{'}} in the output.

If the use the backslash character~\inQuotes{\textbackslash}\pythonIdx{\textbackslash} to escape characters which may otherwise have some special meaning {\dots} then what do we do if we need a backslash inside of a string?
Easy: We escape it.
The escape sequence \inQuotes{\textbackslash\textbackslash}\pythonIdx{\textbackslash\textbackslash} is converted to a single backslash and \expandafter\pythonil{print("\\\\")} writes \inlinelistingbox{\texttt{\\}} to the output.
Knowing these sequences, we can now try to \pythonil{print("\\"\\'\\\\")}.
The result printed to the output then is~\inlinelistingbox{\texttt{"'\\}}.

Another situation where escape sequences are nice is when we want to have strings that span over multiple lines.
The newline sequence \inQuotes{\textbackslash{n}}\pythonIdx{\textbackslash{n}} represents a \inQuotes{newline character} which causes the console to skip to the next line.
\pythonil{print("Hello\\nWorld!")} will first print \inlinelistingbox{\texttt{Hello}}, then end the current line and begin a new line, and then print \inlinelistingbox{\texttt{World!}}.
Notice that the newline character sequence \inQuotes{\textbackslash{n}} is used in \linux\ and similar systems, whereas \windows\ uses \inQuotes{\textbackslash{r}\textbackslash{n}}\pythonIdx{\textbackslash{r}\textbackslash{n}}.
Under \python, both always work, regardless under which operating system you are working, and you should \emph{always} use \inQuotes{\textbackslash{n}}.
However, only for the sake of completeness, I include the example \pythonil{print("Hello\\r\\nWorld!")} as well, which produces the same output as \pythonil{print("Hello\\nWorld!")}.

You probably have pressed the tabulator key~\keys{\tab} on your keyboard at some time in the past.
It produces something like a \inQuotes{longer space}.
If you want to include a horizontal tabulator in a string, the escape sequence \inQuotes{\textbackslash{t}}\pythonIdx{\textbackslash{t}} is your friend:
\pythonil{print("The horizontal tab is like a bigger space: '\\t'.")} yields \inlinelistingbox{\texttt{The~horizontal~tab~is~like~a~bigger~space:~'~~~~'.}}.

Finally, a backslash can also escape an actual newline in your string.
If you have a string that is too long to write on a single line but you do not want to have a linebreak inside the actual string, you can simply put a backslash, hit \keys{\enter}, and continue the typing the string.
The linebreak will then be ignored entirely.
Therefore, if you print~\pythonil{print("Hello\\}, hit \keys{\enter}, and then continue to write \pythonil{World!")}, this produces the output~\inlinelistingbox{\texttt{HelloWorld!}}.

Escape sequences allow us to write arbitrary text in strings.
We already leared the sequences \inQuotes{\textbraceleft\textbraceleft}\pythonIdx{\textbraceleft\textbraceleft} and \inQuotes{\textbraceright\textbraceright}\pythonIdx{\textbraceright\textbraceright} that were designed for f-strings only.
The backslash-based escape sequence we discussed in this section work for both f-strings and normal strings.%
\endhsection%
%
%
\endhsection%
%
