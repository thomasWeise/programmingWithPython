\hsection{Dunder Methods}%
%
In \python, \emph{everything is an object}~\cite{PSF2024OVAT,J2022PPEIAOSCD}.
Functions, modules, classes, datatypes, values of simple datatypes, and so on -- all are objects.
Many of these objects have special functionality.
For example, we can add, multiply, and divide numerical objects.
We can get string representations for all objects that we can print to the console.
We can iterate over the elements of objects that represent sequences.
We can execute objects that represent functions.
These special functionalities are implemented by so-called \emph{dunder} methods.
\pythonIdx{dunder}Dunder methods have names that begin and end with two underscores, like~\pythonilIdx{\_\_init\_\_}\pythonIdx{dunder!\_\_init\_\_}.
And indeed, \pythonilIdx{\_\_init\_\_}\pythonIdx{dunder!\_\_init\_\_}~is a dunder method, the initializer that creates the attributes of an object.

We already learned that, if we create a subclass of a class, we can define new methods and override existing ones.
We can do the same with dunder methods.
This means that we can implement, create, change, and customize all of the functionalities listed above!%
%
\hsection{\texttt{\_\_str\_\_}, \texttt{\_\_repr\_\_}, and \texttt{\_\_eq\_\_}}%
%
\gitPythonAndOutput{\programmingWithPythonCodeRepo}{09_dunder}{str_vs_repr.py}{--args format}{dunder:str_vs_repr}{%
Comparing the \pythonilIdx{str} and \pythonilIdx{repr} representations of integers, strings, lists, and \python's \pythonilIdx{datetime}\pythonIdx{datetime!datetime}\pythonIdx{datetime!datetime!now}\pythonIdx{datetime!UTC} class.}%
%
In \python, we can distinguish two forms of string representations of a given object~\pythonil{o}:%
%
\begin{itemize}%
%
\item \pythonil{str(o)}\pythonIdx{str} should return a concise and brief representation of the object~\pythonil{o}.
This representation is mainly for end users.
\pythonil{str(o)} invokes the \pythonilIdx{\_\_str\_\_}\pythonIdx{dunder!\_\_str\_\_} dunder method, if it has been implemented.
Otherwise, \pythonilIdx{\_\_repr\_\_}\pythonIdx{dunder!\_\_repr\_\_} is used instead.%
%
\item \pythonil{repr(o)}\pythonIdx{repr} should ideally return a string representation that contains all the information that is needed to re-create the object.
The target audience here are programmers who are working on the code, who may need to write precise information into log files, or who are searching for errors.
\pythonil{repr(o)} invokes the \pythonilIdx{\_\_repr\_\_}\pythonIdx{dunder!\_\_repr\_\_} dunder method, if it has been implemented.
Otherwise, it returns the default representation, which is the type name and ID of the object.%
%
\end{itemize}%
%
These two functions are compared in \cref{lst:dunder:str_vs_repr}.
Here, we first create an integer variable \pythonil{the_int} with value \pythonil{123}.
Both \pythonil{str(the_int)} and \pythonil{repr(the_int)} are \pythonil{"123"}.
This is to be expected, since this is all the information that is needed to completely recreate this value and, at the same time, it is also the most concise way to present the value.

We then create another variable \pythonil{the_str} with value \pythonil{"123"}.
Printing \pythonil{the_str} to the \pgls{stdout}, which is equivalent to \pythonil{print(str(the_str))}, will make the text \textil{123} appear on the console.
Printing \pythonil{repr(the_str)}, however, produces~\textil{'123'}.
Notice the added single quotation marks on each side?
These are necessary.
Without them, \pythonil{repr(the_str)} and \pythonil{repr(the_int)} would be the same.
We could not distinguish whether the value we printed was a string or an integer.
This, of course, matters only if we care about the internal workings of our program.
This is the purpose for the existence of~\pythonilIdx{repr}.%
%
\begin{sloppypar}%
Next, we create two collections.
First comes the list~\pythonil{l1}, which contains the three integers~\pythonil{1}, \pythonil{2}, and~\pythonil{3}.
Then we create the list~\pythonil{l2}, which contains the three strings~\pythonil{"1"}, \pythonil{"2"}, and~\pythonil{"3"}.
Then we print both lists, which will use \pythonil{str(l1)} and \pythonil{str(l2)} internally.
The result of \pythonil{print(f"\{l1 = \}, but \{l2 = \}")} is \textil{l1 = [1, 2, 3], but l2 = ['1', '2', '3']}.
Notice that the single quotation marks around the string elements of \pythonil{l2} are printed?
When obtaining the string representations of the standard \python\ collections with either \pythonilIdx{str} or \pythonilIdx{repr}, the elements of the collections are converted to strings using \pythonilIdx{repr}, not~\pythonilIdx{str}~\cite{PEP3140}.
Otherwise, we could not distinguish \pythonil{l1} and \pythonil{l2} in the output.%
\end{sloppypar}%
%
Another good example of the difference between \pythonilIdx{str} and \pythonilIdx{repr} is \python's \pythonilIdx{datetime}\pythonIdx{datetime!datetime} class.
We will not discuss this class here in any detail.
It suffices to know that instances of this class represent a combination of a date and a time.
In the program, we first import the class \pythonilIdx{datetime} from the module of the same name.
We create a variable \pythonil{right\_now} and assign to it the result of the function \pythonilIdx{now}\pythonIdx{datetime!datetime!now}, which returns an object representing, well, today and the current time.\footnote{%
In the output of our program given in \cref{exec:dunder:str_vs_repr}, you cannot see the time of your reading, but the time when this book was compiled.}

If we want to print the result of the \pythonilIdx{str} function applied to an object~\pythonil{o} in an \pgls{fstring}, then we can either do this using the format specifier~\pythonil{!s}\pythonIdx{"!s} or by printing the result of \pythonil{str(o)}.
The former variant is usually preferred.
Anyway, we find that the simple string representation of a \pythonilIdx{datetime} object is, well, a simple human readable date and time string.
The result of the function \pythonilIdx{repr} for an object~\pythonil{o} can be obtained using the format specifier~\pythonil{!r}\pythonIdx{"!r} or by printing the result of \pythonil{repr(o)}.
Doing this with a \pythonilIdx{datetime} object gives us all the information that we need to manually recreate the object.
We could copy the output of \pythonilIdx{repr} from \cref{exec:dunder:str_vs_repr} into the \python\ console!
This would re-create the \pythonil{right\_now} object with the same data.
This would also work with the string representations that we printed for our lists \pythonil{l1} and \pythonil{l2} above.

\gitPythonAndOutput{\programmingWithPythonCodeRepo}{09_dunder}{point_user_2.py}{--args format}{dunder:point_user_2}{%
Investigating string representations and equality for the class~\pythonil{Point}.}%
%
Let us now move a bit backwards and revisit a previous example we created by ourselves.
In \cref{sec:immutableClassPoints2D}, we created the class \pythonil{Point} for representing points in the two-dimensional Euclidean plane~(see \cref{lst:classes:point}).
This class turned out to be quite useful when we went on to implement classes for different two-dimensional geometric shapes.
Here, we already implemented one dunder method, the initializer~\pythonilIdx{\_\_init\_\_}\pythonIdx{dunder!\_\_init\_\_}.
Let us play with this class a bit more.

In \cref{lst:dunder:point_user_2}, we create three instances of this class.
\pythonil{p1}~represents the coordinates~$(3,5)$, \pythonil{p2}~stores~$(7, 8)$, and~\pythonil{p3}~has the same coordinates as~\pythonil{p1}.
In this program, we first print the \pythonil{str} and \pythonil{repr} results for~\pythonil{p1}.
We immediately find them very unsatisfying.
Since we implemented neither \pythonilIdx{\_\_str\_\_}\pythonIdx{dunder!\_\_str\_\_} nor \pythonilIdx{\_\_repr\_\_}\pythonIdx{dunder!\_\_repr\_\_}, the default result for \pythonil{str} falls back to the result of \pythonil{repr} which then falls back to just the type name and object~ID.
This gives us basically no useful information.

While we are on the subject of \inQuotes{not useful,} there is another aspect of our \pythonil{Point} class that does not show useful behavior.
Way back in \cref{sec:equalityAndIdentity}, we discussed the difference between object identity and object equality.
All three variables~\pythonil{p1}, \pythonil{p2}, and~\pythonil{p3} point to different objects.
While \pythonil{p1 is p1}\pythonIdx{is} is obviously \pythonil{True}, \pythonil{p1 is p2} and \pythonil{p1 is p3} are obviously~\pythonil{False}.
The three objects are not all different instances of~\pythonil{Point}, so this is expected.

However, we find it annoying that \pythonil{p1 == p3}\pythonIdx{==} is \pythonil{False}, too.
\pythonil{p1 == p2} should be (and is) \pythonil{False}, because the two points are different.
But the two points \pythonil{p1} and \pythonil{p3} have the same coordinates.
They should be considered equal for all intents and purposes.
Vice versa, \pythonil{p1 != p2}\pythonIdx{"!=} should be (and is) \pythonil{True}, but \pythonil{p1 != p3}\pythonIdx{"!=} should be \pythonil{False} but turns out to be \pythonil{True}.

The reason for this is that \python\ cannot know when and why instances of our own class should be equal.
So it simply assumes that equality~$=$~identity, i.e., only identical instances are equal.
We could fix this by implementing the \pythonilIdx{\_\_eq\_\_}\pythonIdx{dunder!\_\_eq\_\_} dunder method.
This method would receive an arbitrary object~\pythonil{other} as input and should return \pythonil{True} if that is equal to the object whose method was invoked.

If you implement \pythonilIdx{\_\_eq\_\_}\pythonIdx{dunder!\_\_eq\_\_}, \python\ will make the reasonable assumption that \pythonil{(a != b) == not (a == b)}\pythonIdx{"!=}\pythonIdx{==}, i.e., assume that two objects are unequal if and only if they are not equal~\cite{PEP207}.
However, this is not necessarily always the case\footnote{%
In~\cite{PEP207}, it is stated that IEEE~754 floating point numbers do not satisfy that \pythonilIdx{==} and \pythonil{!=}\pythonIdx{"!=} are each other's complements. %
However, I could not find for an example where this was true in the standard~\cite{IEEE2019ISFFPA}, maybe with the exception of signaling~\pythonilsIdx{nan}, which does not matter in \python. %
Maybe it was true for some \python\ implementations back then, as~\cite{PEP754} indicates.%
}. %
Therefore, \python\ also allows us to implement an \pythonilIdx{\_\_ne\_\_}\pythonIdx{dunder!\_\_ne\_\_} dunder method to realize inequality differently or, potentially, more efficiently, instead~\cite{PEP207}.

Finally, we compare whether \pythonil{p1} is the same as the integer number~\pythonil{5}.
This, obviously, should return~\pythonil{False}.
And it does so.
This is because the two objects~\pythonil{p1} and~\pythonil{5} are not identical.
The default equality comparison only checks for identity.
If implement \pythonilIdx{\_\_eq\_\_} by ourselves, this method should clearly return a value that makes \pythonil{p1 == 5} become~\pythonil{False} as well.
Anything else would be nonsense.

\gitPython{\programmingWithPythonCodeRepo}{09_dunder/point_with_dunder.py}{--args format}{dunder:point_with_dunder}{%
Our \pythonil{Point} class, extended with the \pythonilIdx{\_\_str\_\_}\pythonIdx{dunder!\_\_str\_\_}, \pythonilIdx{\_\_repr\_\_}\pythonIdx{dunder!\_\_repr\_\_}, and \pythonilIdx{\_\_eq\_\_}\pythonIdx{dunder!\_\_eq\_\_}\pythonIdx{NotImplementedType} dunder methods.}%
%
\gitPythonAndOutput{\programmingWithPythonCodeRepo}{09_dunder}{point_with_dunder_user.py}{--args format}{dunder:point_with_dunder_user}{%
The same program exploring string representations and equality as shown in \cref{lst:dunder:point_user_2}, but this time using our new \pythonil{Point} class from \cref{lst:dunder:point_with_dunder}.}%

In order to fix all of the problems discussed above, we implement the three dunder methods \pythonilIdx{\_\_str\_\_}\pythonIdx{dunder!\_\_str\_\_}, \pythonilIdx{\_\_repr\_\_}\pythonIdx{dunder!\_\_repr\_\_}, and \pythonilIdx{\_\_eq\_\_}\pythonIdx{dunder!\_\_eq\_\_} for our \pythonil{Point} class in \cref{lst:dunder:point_with_dunder}.
The concise string representation returned by \pythonilIdx{\_\_str\_\_}\pythonIdx{dunder!\_\_str\_\_} will just be the point coordinates in parentheses.
This offers all the information needed at a glance, but it could be mistaken with a tuple as string.
Therefore, the canonical string representation produced by \pythonilIdx{\_\_repr\_\_}\pythonIdx{dunder!\_\_repr\_\_} will return a string of the shape~\pythonil{"Point(x, y)"}.

Finally, the \pythonilIdx{\_\_eq\_\_}\pythonIdx{dunder!\_\_eq\_\_} method will first check if the \pythonil{other} object is an instance of \pythonil{Point}.
If so, it will return \pythonil{True} if and only if the \pythonil{x} and \pythonil{y} coordinate of the \pythonil{other} point are the same as of the point \pythonil{self}.
Otherwise, it will return the constant \pythonilIdx{NotImplemented}:%
%
\quotation{PSF2024BIC}{%
A special value which should be returned by the binary special methods [\dots] to indicate that the operation is not implemented with respect to the other type\dots\medskip\\\strut\hspace{1cm}\strut%
\emph{Note:}~When a binary (or in-place) method returns \pythonilIdx{NotImplemented} the interpreter will try the reflected operation on the other type (or some other fallback, depending on the operator). %
If all attempts return \pythonilIdx{NotImplemented}, the interpreter will raise an appropriate exception. %
Incorrectly returning \pythonilIdx{NotImplemented} will result in a misleading error message or the \pythonilIdx{NotImplemented} value being returned to \python\ code.
}%
%
In other words, our \pythonilIdx{\_\_eq\_\_} method can only compare the current~\pythonil{Point} for equality with another~\pythonil{Point}.
If \pythonil{other} is not an instance of~\pythonil{Point}, then no way to compare for equality with it exists.
Now, we could return \pythonil{False} in this case, which would be fine as well.
Returning \pythonilIdx{NotImplemented} will give us the same result in comparisons with objects of other types~(like~\pythonil{5}).
However, it keeps an avenue open for other programmers to design new classes which support comparison with our \pythonil{Point} instances in a consistent way.
When we implement the \pythonilIdx{\_\_eq\_\_} method like this, the proper \pgls{typeHint} for the return value is \pythonil{bool | NotImplementedType}\pythonIdx{NotImplementedType}.

\Cref{lst:dunder:point_with_dunder_user} is the same as \cref{lst:dunder:point_user_2}, but now uses this new variant of our class \pythonil{Point}.
As you can see in \cref{exec:dunder:point_with_dunder_user}, its output now matches much better to what one would expect.%
%
\FloatBarrier%
\endhsection%
%
%
\hsection{Objects in Sets and as Keys in Dictionaries:~\texttt{\_\_hash\_\_}, \texttt{\_\_eq\_\_}}%
\label{sec:hashDunder}%
%
\gitPython{\programmingWithPythonCodeRepo}{09_dunder/point_with_hash.py}{--args format}{dunder:point_with_hash}{%
Our \pythonil{Point} class, extended with the \pythonilIdx{\_\_eq\_\_}\pythonIdx{dunder!\_\_eq\_\_} and \pythonilIdx{\_\_hash\_\_}\pythonIdx{dunder!\_\_hash\_\_} dunder methods.}%
%
\gitPythonAndOutput{\programmingWithPythonCodeRepo}{09_dunder}{point_with_hash_user.py}{--args format}{dunder:point_with_hash_user}{%
Using the new \pythonil{Point} class from \cref{lst:dunder:point_with_hash} in sets and dictionaries.}%
%
Our \pythonil{Point} objects are immutable and just consist of two numerical coordinates.
Maybe there could be an application where someone would like to use them as keys for a dictionary or would like to construct a set of points.
For this to be possible, two things are needed:%
%
\begin{itemize}%
%
\item A dunder method \pythonilIdx{\_\_eq\_\_} that compares two \pythonils{Point} for equality. %
This, we already have done in \cref{lst:dunder:point_with_dunder}.%
%
\item A dunder method \pythonilIdx{\_\_hash\_\_} that returns the hash value of a \pythonil{Point} in form of an~\pythonil{int}.%
%
\end{itemize}%
%
For these two methods, it must hold that~\cite{PSF2024OH}%
%
\begin{equation}%
\pythonil{a.\_\_eq\_\_(b)} \Rightarrow \pythonil{a.\_\_hash\_\_()} = \pythonil{b.\_\_hash\_\_()}%
\label{eq:eqAndHash1}%
\end{equation}%
%
This is equivalent~\cite{PSF2024BIE,PSF2024OH} to:%
%
\begin{equation}%
\pythonil{a == b} \Rightarrow \pythonil{hash(a)} = \pythonil{hash(b)}%
\label{eq:eqAndHash2}%
\end{equation}%
%
But let us step back a bit here.
What is a hash value?
Why is an integer hash value needed?
Why does the equality of two objects require them to have the same hash value?

Dictionaries in \python\ (and \pgls{Java}) internally use tables, where key-value relationships are stored~\cite{G2020PHTUTH,L2011PDI}.
Sets are basically the same, but only store the keys.
The internal tables could be represented as lists.
Differently from lists, new elements are not added at the end.
Instead, they would be more like lists of a fixed length where new elements are placed at specific indices where they can be found again.
These hash tables~\cite{K1998SAS,CLRS2009ITA,SKS2019DSC} are very fast.
They have an element-wise access/update time complexity of~\bigOb{1}~\cite{H2024PBOTTCODDSIPP33,B2023T,N2022CCSFPO}.
As you know, lists can be indexed by integers.
Since we also want to be able to use objects that are \emph{not} integers as keys, too, we need a way to \inQuotes{translate} these objects to integers.
That is what \pythonilIdx{\_\_hash\_\_} is supposed to do.

Luckily, \pythonilIdx{\_\_hash\_\_} does not need to compute a valid index into such a table.
That would indeed not be possible:
The \pythonilIdx{\_\_hash\_\_} method of an object~\pythonil{a} cannot know the length of the internal table underlying a dictionary or set where the object~\pythonil{a} will be stored.
Instead, all it needs to do is to return one integer value that represents~\pythonil{a}.
The dictionary/set implementation is then responsible for translating this integer into a valid index into its internal table.
It can use \pgls{modulodiv} for this.
It will also do lots of other things, e.g., taking care of collisions, i.e., cases where two different objects have the same hashes (or different hashes that end up mapping to the same index)~\cite{G2020PHTUTH,L2011PDI}.
None of this is important here.

What is important is that the hash values are needed to find the objects in the dictionaries and set.
We want to know whether the object~\pythonil{a} is \pythonilIdx{in} the set~\pythonil{s}?
Then the set~\pythonil{s} uses \pythonil{hash(a)}\pythonIdx{hash} which invokes~\pythonil{a.__hash__()}\pythonIdx{\_\_hash\_\_} to get the hash value of~\pythonil{a}.\footnote{%
This works the same way in which \pythonil{repr(a)} would invoke \pythonil{a.__repr__()} if it is defined.}
It translates the hash value to an index.
It checks its internal table whether there is an object~\pythonil{b} at that index with~\pythonil{b == a}.
If yes, then, well, \pythonil{a} is in the set~\pythonil{s}, i.e., \pythonil{a in s} yields~\pythonil{True}.
If not, then not.
As said, the reality is more complex, because of potentially occurring collisions, but for our excursion here, this very coarse approximation of how this works shall suffice.

Anyway, if we want to add an object to the set~\pythonil{s}:
Then again the index is computed via the hash value and if the object is not already there, it is placed there.
Dictionaries work the same, just use key-value relationships, where the hash values of the keys are computed to find the right places in the internal tables.
The details are (for the third time), unimportant here -- but you can read them in these very interesting sources here~\cite{G2020PHTUTH,L2011PDI}.

It is already clear, however, that calling \pythonilIdx{\_\_hash\_\_} twice for the same object~\pythonil{a} must return the same value.
Since this hash value is used to find the place in the table where the object should be, this must never change.
This is also why dictionary (and set) keys must be immutable~(see~\cref{bp:dictKeys,bp:setsImmutable}).

It is also clear that two objects~\pythonil{a} and~\pythonil{b} that are \emph{equal} must also have the same hash value.
If two objects are equal, it should be that $\pythonil{a in s}=\pythonil{b in s}$.
Otherwise, it could be that \pythonil{"123" in s} is \pythonil{True} for the string constant~\pythonil{"123"}, but if we read the string~\pythonil{"123"} from a file, \pythonil{"123" in s} could return~\pythonil{False}.
That would make no sense at all.

With that out of the way, we can now make our \pythonil{Point} class hashable.
In \cref{lst:dunder:point_with_hash}, we modify the \pythonil{Point} class from \cref{lst:dunder:point_with_dunder}.
We retain the implementation of~\pythonilIdx{\_\_eq\_\_} and add the method~\pythonilIdx{\_\_hash\_\_}.%
%
\quotation{PSF2024OH}{{\dots}The \pythonil{\_\_hash\_\_()}\pythonIdx{\_\_hash\_\_}\pythonIdx{dunder!\_\_hash\_\_} method should return an integer. %
The only required property is that objects which compare equal have the same hash value; %
it is advised to mix together the hash values of the components of the object that also play a part in comparison of objects by packing them into a \pythonil{tuple} and hashing the tuple.}%
%
\bestPractice{hash}{%
For implementing \pythonilIdx{\_\_eq\_\_} and \pythonilIdx{\_\_hash\_\_}, the following rules hold~\cite{PSF2024OH}:%
\sloppy%
\begin{itemize}\sloppy%
%
\item Only immutable classes are allowed to implement \pythonilIdx{\_\_hash\_\_}, i.e., only classes where all attributes have the \pythonilIdx{Final} \pgls{typeHint} and are only assigned on the initialize~\pythonilIdx{\_\_init\_\_}.%
%
\item The result of \pythonil{a.\_\_hash\_\_()} must never change (since \pythonil{a} must never change either).%
%
\item If a class does not define \pythonilIdx{\_\_eq\_\_}, it cannot implement \pythonilIdx{\_\_hash\_\_} either.%
%
\item Instances of a class that implements \pythonilIdx{\_\_eq\_\_} but not \pythonilIdx{\_\_hash\_\_} cannot be used as keys in a dictionary or set.%
%
\item Only instances of a class that implements both \pythonilIdx{\_\_eq\_\_} and \pythonilIdx{\_\_hash\_\_} can be used as keys in dictionaries or sets.%
%
\item Then, the results of \pythonilIdx{\_\_eq\_\_} and \pythonilIdx{\_\_hash\_\_} must be computed using the exactly same attributes. %
In other words, the attributes of an object~\pythonil{a} that determine the results of~\pythonil{a.\_\_eq\_\_(...)} must be exactly the same as those determining the results of~\pythonil{a.\_\_hash\_\_(...)}. %
%
\item It is best to compute \pythonil{a.\_\_hash\_\_(...)} by simply putting all of these attributes into a \pythonil{tuple} and then passing this \pythonil{tuple} to \pythonilIdx{hash}.%
%
\item Two objects that are equal must have the same hash value, i.e., \cref{eq:eqAndHash1,eq:eqAndHash2} must hold.%
\end{itemize}%
\fussy%
}%
%
That sounds complicated, but is actually very easy.
The only attributes that play a role in our \pythonilIdx{\_\_eq\_\_} method are the two coordinates of the point, \pythonil{self.x} and~\pythonil{self.y}.
So the result~\pythonilIdx{\_\_hash\_\_} should simply be~\pythonil{hash((self.x, self.y))}\pythonIdx{hash}.
The double-parentheses are because this basically means \pythonil{t = (self.x, self.y)} and then computing~\pythonil{hash(t)}.%
%
\begin{sloppypar}%
One may be a bit scared regarding integers and floats.
We permitted the coordinates of our points to be either \pythonils{int} or \pythonils{float}.
Since \pythonil{5.0 == 5} holds, we could feel anxious whether \pythonil{hash(5.0) == hash(5)}\pythonIdx{hash} would also hold.
If \emph{not}, then something like \pythonil{hash((5.0, 3)) != hash((5, 3))} could happen, which could lead to~\pythonil{Point(5.0, 3).\_\_hash\_\_() != Point(5, 3).\_\_hash\_\_()} while \pythonil{Point(5.0, 3).\_\_eq\_\_(Point(5, 3))} is~\pythonil{True}.
This would then violate~\cref{bp:hash}.%
\end{sloppypar}%
%
If that would happen, we could create sets that contain equal elements multiple times.
Which, in turn, would violate the definition of sets.
That would be a very counter-intuitive bug in our code.
Actually, I secretly planned to use this as a very tricky example for learning how to use the debugger{\dots}
Alas, the developers of \python\ have already solved this:%
%
\quotation{PSF2024BIF}{Numeric values that compare equal have the same \pythonilIdx{hash} value (even if they are of different types, as is the case for~\pythonil{1} and~\pythonil{1.0}).}%
%
Therefore, we can indeed implement \pythonilIdx{\_\_hash\_\_} with a single line of code in~\cref{sec:hashDunder}.
And I will later find another example on how the debugger can be used to spot errors in code.%
%
\begin{sloppypar}%
We use our new variant of the \pythonil{Point} class in~\cref{lst:dunder:point_with_hash_user}.
We again first create three points~\pythonil{p1 = Point(3, 5)}, \pythonil{p2 = Point(7, 8)} and \pythonil{p3 = Point(3, 5.0)}.
\pythonil{p1 == p2} is \pythonil{False}, while \pythonil{p1 == p3} is \pythonil{True}, despite the \pythonil{y}\nobreakdashes-coordinate of \pythonil{p1} is an~\pythonil{int} and the one of~\pythonil{p2} is a~\pythonil{float}~(but with the same value).
When we create the set~\pythonil{points} as~\pythonil{\{p1, p2, p3\}}, it will have the size~2.
Since \pythonil{p1 == p3}, only one of these two objects is stored in the set.
However, \pythonil{p1 in points}, \pythonil{p2 in points}, and~\pythonil{p3 in points} are all~\pythonil{True}.
This is because \pythonil{p1} and \pythonil{p3} also have the same hash value.%
\end{sloppypar}%
%
If we create a new point~\pythonil{p4} with coordinates equal to those of~\pythonil{p2}, then \pythonil{p4 in points} will also hold.
However, a point~\pythonil{p5} whose coordinates are different from those of~\pythonil{p1} and~\pythonil{p2} will not be an element of~\pythonil{points}, i.e., \pythonil{p5 in points} would be~\pythonil{False}.

Now we can also use the instances of our class~\pythonil{Point} as keys for a dictionary~\pythonil{point_vals}.
The same dictionary operations as discussed way back in~\cref{sec:dictionaries} can be used without problems.%
%
\FloatBarrier%
\endhsection%
%
\hsection{Arithmetic Dunder and Ordering}%
%
\gitPython{\programmingWithPythonCodeRepo}{09_dunder/fraction.py}{--args format --labels part_1}{dunder:fraction:part_1}{%
Part~1 of the \pythonil{Fraction} class: The initializer \pythonilIdx{\_\_init\_\_} and global constants.}%
\afterpage{\clearpage}%
%
Much of \python's syntactic behavior can be grounded on dunder methods.
Indeed, even the arithmetic operators~\pythonilIdx{+}, \pythonilIdx{-}, \pythonilIdx{*}, and \pythonilIdx{/}.
This allows us to define new numerical types if we want.

Here, we will do exactly that:
We implement the basic arithmetic operations for a class~\pythonil{Fraction} that represents fractions~$q\in\rationalNumbers$, i.e., it holds that~$q=\frac{a}{b}$ with~$a,b\in\integerNumbers$ and~$b\neq0$.\footnote{
\python\ already has such a type built-in. %
Our goal here is to explore dunder methods, so we make our own class instead. %
In any actual application, you would use the more efficient class \pythonilIdx{Fraction} from the module~\pythonilIdx{fractions}~\cite{PSF2024FRN}.%
}
In other words, we want to pour primary school mathematics into a new numerical type.
To refresh our memory, $a$~is called the \pgls{numerator} and $b$~is called the \pgls{denominator} of the fraction~$\frac{a}{b}$.

The overall code for this class is a bit longer compared to our previous examples.
We therefore split it into several parts, namely~\cref{lst:dunder:fraction:part_1,lst:dunder:fraction:part_2,lst:dunder:fraction:part_3,lst:dunder:fraction:part_4,lst:dunder:fraction:part_5} (and later add \cref{lst:dunder:fraction:part_6}).
At first we need to decide which attributes such a class would need.
We construct the initializer dunder method \pythonilIdx{\_\_init\_\_} in \cref{lst:dunder:fraction:part_1}.

Since the fraction~$\frac{a}{b}$ can be defined by the two integer numbers~$a$ and~$b$, it makes sense to also have two \pythonil{int} attributes~\pythonil{a} and~\pythonil{b} in our~\pythonil{Fraction} class.
We want our numbers to be immutable, because like you cannot change the value of~\pythonil{5}, you should also not be able to change the value of~\pythonil{1/3}.
The attributes will therefore receive the \pgls{typeHint} \pythonilIdx{Final[int]}.

Our fractions should be \emph{canonical}.
It is totally possible that two fractions~$\frac{a}{b}=\frac{c}{d}$ with $a\neq c$ or $b\neq c$.
This is the case for, let's say, $\frac{-9}{3}$ and $\frac{12}{-4}$.
In such cases we want to ideally store them in objects that have exactly the same attribute values.

The fractions~$\frac{1}{2}$ and~$\frac{2}{4}$ are the same.
They should both be represented as~$\frac{1}{2}$.
It is clear that~$\frac{a}{b}=\frac{c*a}{c*b}$ for all integer numbers~$a,b,c\in\integerNumbers$ and~$b,c>0$.
Before storing~$a$ and~$b$, we will divide both numbers by their \emph{greatest common divisor}.
Back in \cref{sec:definingFunctions}, we implemented our own function~\pythonilIdx{gcd} for computing the greatest common divisor based on the Euclidean algorithm.
This time, we will use the \pythonilIdx{gcd} function from the \pythonilIdx{math} module directly.
Anyway, dividing the \pgls{numerator} and \pgls{denominator} by their \pythonilIdx{gcd} ensures that our fractions are represented in a compact way.

This leaves only the question where the sign should be stored.
Obviously, $\frac{-5}{2}=\frac{5}{-2}$ and $\frac{5}{2}=\frac{-5}{-2}$.
We decide that the sign of the fraction is always stored in the attribute~\pythonil{a}.
In other words, if $\frac{a}{b}<0$, then \pythonil{a} will be negative, otherwise it should be positive.
It can only be that $\frac{a}{b}<0$ if exactly one of $a<0$ or $b<0$ is true.
Therefore, the sign of our fraction is determined by \pythonil{-1 if ((a < 0) != (b < 0)) else 1}.

In the initializer, we also need to make sure that things like~$\frac{7}{0}$ do not happen.
In this case, we will \pythonilIdx{raise} an \pythonilIdx{ZeroDivisionError}.

As last step, we must add proper \pglspl{doctest} to the initializer.
We need to check whether the values~$a$ and~$b$ are properly stored in the attributes~\pythonil{a} and~\pythonil{b}.
Then we need to check whether our canonicalization by dividing with the \pythonilIdx{gcd} correctly maps~$\frac{12}{2}$ to~$\frac{6}{1}$.
And we need to verify that~$\frac{2}{-12}$ and~$\frac{-2}{12}$ correctly become~$\frac{-1}{6}$ while $\frac{-2}{-12}$~becomes~$\frac{1}{6}$.
The special case of the number zero also needs to be checked:
We know that \pythonil{gcd(0, -9) = -9}, so it should work, but it is better to verify that~$\frac{0}{-9}$ is indeed mapped to~$\frac{0}{1}$.
Finally, we need to verify that the \pythonilIdx{ZeroDivisionError} is indeed raised when we try to instantiate \pythonil{Fraction} with a zero \pgls{denominator}.
Without needing to read the actual code of \pythonil{\_\_init\_\_}, a user can therefore already learn a lot about how our class \pythonil{Fraction} represents rational numbers just from the \pglspl{doctest}.

Several special fractions will occur very often in computations.
Instead of creating them again and again, we can define them as constants.
A constant is a variable that must never be changed.%
%
\bestPractice{constants}{%
Constants are module-level variables which must be assign a value upon definition and which must be annotated with the \pgls{typeHint}~\pythonilIdx{Final}.%
}%
\bestPractice{constNames}{%
The names of constants contain only capital letters with underscores separating words. %
Examples include \pythonil{MAX_OVERFLOW} and \pythonil{TOTAL}~\cite{PEP8}.%
}%
\bestPractice{constDoc}{%
Constants are documented by writing a comment starting with \pythonilIdx{\#: } immediately above them~\cite{SD2024DCAD}.%
}%
%
We define three constants, \pythonil{ZERO}, \pythonil{ONE}, and \pythonil{ONE_HALF}, which hold corresponding instances of \pythonil{Fraction}.
These numbers are often used, and providing them as constant can safe both runtime and memory.

\gitPython{\programmingWithPythonCodeRepo}{09_dunder/fraction.py}{--args format --labels part_2}{dunder:fraction:part_2}{%
Part~2 of the \pythonil{Fraction} class: String representation via \pythonilIdx{\_\_str\_\_} and \pythonilIdx{\_\_repr\_\_}.}
\afterpage{\clearpage}

Did you notice that we had to write \pglspl{doctest} in the \pgls{docstring} of our class in a very inconvenient way?
This was because we did not yet define the \pythonilIdx{\_\_str\_\_} and \pythonilIdx{\_\_repr\_\_} methods for our class \pythonil{Fraction}.
We do this in \cref{lst:dunder:fraction:part_2}.
The method \pythonilIdx{\_\_str\_\_} is supposed to return a compact representation of the fractions.
We implement such that it returns \pythonil{self.a} as string if the \pgls{denominator} is one, i.e., if~\pythonil{self.b == 1}.
Otherwise, it should return \pythonil{f"\{self.a\}/\{self.b\}"}.
This is easy and clear enough for each user to immediately recognize the value of the fraction.
It is also ambiguous, though, because one cannot distinguish \pythonil{str(Fraction(12, 1))} from \pythonil{str(12)}, i.e., fractions that represent integer numbers will produce the same strings as integer numbers.
The \pythonilIdx{\_\_repr\_\_} method exists to produce unambiguous output.
We implement it to return~\pythonil{f\"Fraction(\{self.a\}, \{self.b\})"}.

In the \pglspl{docstring} of both methods, we include \pglspl{doctest}.
Notice that \pythonilIdx{\_\_str\_\_} is used if pass an object to~\pythonilIdx{print}.
This means that we can compare the expected output of \pythonil{f.\_\_str\_\_()} for a fraction~\pythonil{f} to the result of~\pythonil{print(f)}.
Otherwise, \pglspl{doctest} always convert objects to string using~\pythonilIdx{repr}, meaning that the line~\pythonil{Fraction(-5, 12)} in the \pgls{doctest} of \pythonilIdx{\_\_repr\_\_} actually calls \pythonil{repr(Fraction(-5, 12)}.
Anyway, with the string conversion out of the way, we can begin to implement mathematical operators.

\gitPython{\programmingWithPythonCodeRepo}{09_dunder/fraction.py}{--args format --labels part_3}{dunder:fraction:part_3}{%
Part~3 of the \pythonil{Fraction} class: Addition (via \pythonilIdx{\_\_add\_\_}\pythonIdx{dunder!\_\_add\_\_}) and subtraction (via \pythonilIdx{\_\_sub\_\_}\pythonIdx{dunder!\_\_sub\_\_}).}%
%
\gitPython{\programmingWithPythonCodeRepo}{09_dunder/fraction.py}{--args format --labels part_4}{dunder:fraction:part_4}{%
Part~4 of the \pythonil{Fraction} class: Multiplication (via \pythonilIdx{\_\_mul\_\_}\pythonIdx{dunder!\_\_mul\_\_}), division (via \pythonilIdx{\_\_truediv\_\_}\pythonIdx{dunder!\_\_truediv\_\_}), and computing the absolute value (via \pythonilIdx{\_\_abs\_\_}\pythonIdx{dunder!\_\_abs\_\_}).}%
%
\afterpage{\clearpage}

In \cref{lst:dunder:fraction:part_3}, we want to enable our \pythonil{Fraction} class to be used with the \pythonil{+} and \pythonil{-} operators.
In \python, doing something like \pythonil{x + y} will invoke \pythonil{x.\_\_add\_\_(y)}, if the class of~\pythonil{x} defines the \pythonilIdx{\_\_add\_\_}\pythonIdx{dunder!\_\_add\_\_} method.
From primary school, we remember that $\frac{a}{b}+{c}{d} = \frac{a*d+c*b}{b*d}$.
Therefore, if \pythonil{other} is also an instance\pythonIdx{isinstance} of \pythonil{Fraction}, \pythonil{\_\_add\_\_(other)} computes the result like that and creates a new \pythonil{Fraction}.
Notice that the initializer of that new fraction will automatically normalize the fraction by using~\pythonilIdx{gcd}.
If \pythonil{other} is not an instance of \pythonil{Fraction}, we return \pythonilIdx{NotImplemented}, because this would enable \python\ to look for other routes to perform addition with our objects.\footnote{%
\python\ would then look whether \pythonil{other} provides an \pythonilIdx{\_\_radd\_\_}\pythonIdx{dunder!\_\_radd\_\_} method that does not return~\pythonilIdx{NotImplemented} {\dots} but we will not implement all possible arithmetic dunder methods here so we skip this one.%
}%
The behavior of this method is again be tested with \pglspl{doctest}.
These check that $\frac{1}{3} + \frac{1}{2}$ actually yields~$\frac{5}{6}$ and that $\frac{1}{2}+\frac{1}{2}$ really returns~$\frac{1}{1}$.
They also check correct normalization by trying~$\frac{21}{-12}+\frac{-33}{42}=\frac{882+396}{-504}=\frac{1278}{-504}=\frac{18*1278}{18*-28}=\frac{-71}{28}$.

After confirming that these tests succeed, we continue by implementing the \pythonilIdx{\_\_sub\_\_}\pythonIdx{dunder!\_\_sub\_\_} method in exactly the same way.
This enables subtraction by using~\pythonilIdx{-}, because \pythonil{x - y} will invoke \pythonil{x.\_\_sub\_\_(y)}, if the class of~\pythonil{x} defines the \pythonilIdx{\_\_sub\_\_}\pythonIdx{dunder!\_\_sub\_\_} method.
Clearly, $\frac{a}{b}-{c}{d} = \frac{a*d-c*b}{b*d}$.
As \pglspl{doctest}, the same three cases as used for \pythonil{\_\_add\_\_} will do.

In \cref{lst:dunder:fraction:part_4}, we now focus on multiplication and division.
The \pythonil{*}~operation will utilize a \pythonilIdx{\_\_mul\_\_}\pythonIdx{dunder!\_\_mul\_\_}, if implemented, and that \pythonil{/}~operation uses \pythonilIdx{\_\_truediv\_\_}\pythonIdx{dunder!\_\_truediv\_\_}.
Multiplying the fractions~$\frac{a}{b}$ and~$\frac{c}{d}$ yields~$\frac{a*c}{b*d}$.
Dividing~$\frac{a}{b}$ by~$\frac{c}{d}$ yields~$\frac{a*d}{b*c}$.
The dunder methods can be implemented according to the same schematic as before.
We test multiplication by confirming that $\frac{6}{19}*\frac{3}{-7}=\frac{6 * 3}{19*-7}=\frac{18}{-133}=\frac{-18}{133}$.
The division is tested by computing whether $\frac{6}{19}*\frac{3}{-7}=\frac{6 * -7}{19*3}=\frac{-42}{57}=\frac{3*-14}{3*19}$ indeed gives us~$\frac{-14}{19}$.

Now we also implement support for the \pythonilIdx{abs} function.
\pythonilIdx{abs} returns the absolute value of a number.
Therefore, $\pythonil{abs(5)}=\pythonil{abs(-5)}=\pythonil{5}$.
If present, \pythonil{abs(x)} will invoke~\pythonil{x.\_\_abs\_\_()}\pythonIdx{\_\_abs\_\_}\pythonIdx{dunder!\_\_abs\_\_}.
We can implement this method as follows:
If our fraction is positive, then it can be returned as-is.
Otherwise, we return a new, positive variant of our fraction by simply flipping the sign of it.

\gitPython{\programmingWithPythonCodeRepo}{09_dunder/fraction.py}{--args format --labels part_5}{dunder:fraction:part_5}{%
Part~5 of the \pythonil{Fraction} class: All order-related dunder methods\pythonIdx{\_\_eq\_\_}\pythonIdx{\_\_ne\_\_}\pythonIdx{\_\_lt\_\_}\pythonIdx{\_\_le\_\_}\pythonIdx{\_\_gt\_\_}\pythonIdx{\_\_ge\_\_}\pythonIdx{dunder!\_\_eq\_\_}\pythonIdx{dunder!\_\_ne\_\_}\pythonIdx{dunder!\_\_lt\_\_}\pythonIdx{dunder!\_\_le\_\_}\pythonIdx{dunder!\_\_gt\_\_}\pythonIdx{dunder!\_\_ge\_\_}.}%
%
\gitOutputTool{\programmingWithPythonCodeRepo}{.}{scripts/pytest_doctest.sh 09_dunder fraction.py}{dunder:fraction:doctest}{%
The output of \pytest\ executing the \pglspl{doctest} for our \pythonil{Fraction} class.}%
%
Finally, in \cref{lst:dunder:fraction:part_5} we implement the six rich comparison dunder methods given in~\cite{PEP207}:%
%
\begin{itemize}%
\item \pythonilIdx{\_\_eq\_\_}\pythonIdx{dunder!\_\_eq\_\_} implements the functionality of~\pythonilIdx{==}, as we already discussed before.%
%
\item \pythonilIdx{\_\_ne\_\_}\pythonIdx{dunder!\_\_ne\_\_} implements the functionality of~\pythonilIdx{!=}.%
%
\item \pythonilIdx{\_\_lt\_\_}\pythonIdx{dunder!\_\_lt\_\_} implements the functionality of~\pythonilIdx{<}.%
%
\item \pythonilIdx{\_\_le\_\_}\pythonIdx{dunder!\_\_le\_\_} implements the functionality of~\pythonilIdx{<=}.%
%
\item \pythonilIdx{\_\_gt\_\_}\pythonIdx{dunder!\_\_gt\_\_} implements the functionality of~\pythonilIdx{>}.%
%
\item \pythonilIdx{\_\_ge\_\_}\pythonIdx{dunder!\_\_ge\_\_} implements the functionality of~\pythonilIdx{>=}.%
\end{itemize}%
%
Implementing equality and inequality is rather easy, since our fractions are all normalized.
For two fractions~\pythonil{x} and~\pythonil{y}, it holds only that~\pythonil{x == y} if \pythonil{x.a == y.a} and \pythonil{x.b == y.b}.
\pythonilIdx{\_\_eq\_\_}\pythonIdx{dunder!\_\_eq\_\_} is thus quickly implemented.
\pythonilIdx{\_\_ne\_\_}\pythonIdx{dunder!\_\_ne\_\_} is its complement for the \pythonilIdx{!=}~operator.
\pythonil{x != y} is \pythonil{True} if either \pythonil{x.a != y.a} or \pythonil{x.b != y.b}.

The other four comparison methods can be implemented by remembering how we used the common \pgls{denominator} for addition and subtraction.
We did addition like this:~$\frac{a}{b}+\frac{c}{d}=\frac{a*d}{b*d}+\frac{c*b}{b*d}=\frac{a*d+c*b}{b*d}$.
Looking at this again, we realize that $\frac{a}{b}<\frac{c}{d}$ is the same as~$\frac{a*d}{b*d}<\frac{c*b}{b*d}$, which must be the same as~$a*d<c*b$.
Thus, $\frac{a}{b}\leq\frac{c}{d}$ is the same as~$a*d\leq c*b$.
The greater and greater-or-equal operations can be defined the other way around.

All six comparison operations are defined accordingly in \cref{lst:dunder:fraction:part_5}.
This time, I omitted \pglspl{doctest} for the sake of space.
Matter of fact, I have shortened the code and tests in all of the above code snippets.
For example, we do not check whether the parameters of the initializer \pythonilIdx{\_\_init\_\_} are actually integers (and raise a \pythonilIdx{TypeError} otherwise).
Such checks should then be covered by \pglspl{doctest}.
You should never omit such checks and tests, because in program code, you \emph{do} have space.
Your code does not need to fit on book pages\dots

Anyway, in \cref{exec:dunder:fraction:doctest} we present the output of \pytest\ running the \pglspl{doctest} of all the methods we implemented.
All of them succeed.
This means that we can be fairly confident that using our \pythonil{Fraction} class in real computations would provide us correct results.%
\FloatBarrier%
\endhsection%
%
\hsection{Debugging}%
%
\gitPython{\programmingWithPythonCodeRepo}{09_dunder/fraction_decimal_str_err.py}{--args format --labels part_6}{dunder:fraction_decimal_str_err:part_6}{%
Part~6 of the \pythonil{Fraction} class: Adding a \pythonil{decimal_str} conversation method.}%
%
We now want to use mathematics based on our class \pythonil{Fraction} for some \inQuotes{real} computation.
Remember back in \cref{sec:whileLoop}, we implemented the algorithm of Heron to compute the square root using a \pythonil{while}~loop.
In \cref{sec:functionsInModules}, we then poured this code into a function.
If we revisit this function \pythonil{sqrt} in \cref{lst:functions:my_math}, we notice that it computes the square root using only comparison, addition, multiplication, and division.
We do have these operations available for \pythonils{Fraction}!
This would mean that we could now compute the square root of a number to an arbitrary precision.
We could compute $\sqrt{2}$~accurate to 700~digits!

Except, so far, we do not have anything that would print these digits.
Our \pythonil{\_\_str\_\_} method returns fractions like \pythonil{a/b}.
Had we computed a fraction that approximates~$\sqrt{2}$ to some precision, this could maybe be printed as~$\frac{6369051672525773}{4503599627370496}$.
Instead, we want it to print as~1.4142135623730951.
So we first need to implement a method \pythonil{decimal_str}, which translates a \pythonil{Fraction} to such a decimal string.
Since some fractions, like~$\frac{1}{3}$ and~$\frac{1}{7}$ have never-ending decimal representations, this function needs a parameter \pythonil{max_frac} specifying the maximum number of fractional digits to generate.
We will set it to 100 by default.

In \cref{lst:dunder:fraction_decimal_str_err:part_6} we present the part of our class \pythonil{Fraction} that contains the code converting the fraction to a decimal string.
Like all of our code in \pythonil{Fraction}, it takes the straightforward and probably inefficient route.
The idea is simply to first cut-off the integer part of the fraction and then to produce the fractional digits one-by-one.

We begin our function \pythonil{decimal_str} by first copying the \pgls{numerator} into a variable~\pythonil{a}.
If \pythonil{a == 0}, then the whole fraction is~0 and we can directly return~\pythonil{"0"}.
Otherwise, we check if the fraction is negative.
The Boolean variable \pythonil{negative} is set to \pythonil{True} if \pythonil{a < 0} and to \pythonil{negative} otherwise.
We then make sure that \pythonil{a} is positive by computing~\pythonil{abs(a)}.
Then we also copy the \pgls{denominator} into a variable~\pythonil{b}.

We now want to fill a list~\pythonil{digits} with the digits representing the fraction in a \pythonil{while}~loop.
Let us assume that our fraction is~$-\frac{179}{16}$.
Then \pythonil{negative == True}, \pythonil{a = 179}, and \pythonil{b = 16}.
In the loop body, we append the result of the integer division of \pythonil{a} by~\pythonil{b}, i.e., \pythonil{a // b}, to the list~\pythonil{digits}.
In the first iteration, this gives us \pythonil{179 // 16}.
So the first \inQuotes{digit} we add to \pythonil{digits} is~\pythonil{11}.
This is the integer part of our fraction and this is the only time that a digit larger than~9 can appear.
We now update \pythonil{a} to \pythonil{10 * (a \% b)}.
\pythonilIdx{\%} is the \pgls{modulodiv}, so \pythonil{a \% b} gives us the remainder of the division of~179 by~16, namely~3.
Thus, we get~\pythonil{a = 30}.

In the second iteration, \pythonil{a // b}, i.e., \pythonil{30 // 16}, gives us the next digit~\pythonil{1}.
Now, \pythonil{10 * (a \% b)} gives us~140 as the new value of~\pythonil{a}.
This then gives \pythonil{140 // 16}, namely~8, as the third digit and \pythonil{a} is updated to \pythonil{10 * (a \% b)}, which is~120.
At the beginning of the fourth iteration, \pythonil{a = 120} (while \pythonil{b = 16} remains unchanged).
The fourth value appended to \pythonil{digits} therefore is \pythonil{120 // 16 == 7}.
The variable~\pythonil{a} is updated to the result of \pythonil{10 * (a \% b)}, which is~80.
As last digit, we therefore add \pythonil{80 // 16}, which is~\pythonil{5}.
This is the last digit, because \pythonil{80 \% 16} is~0.
Therefore, \pythonil{a == 0} holds after the fifth iteration.
This makes the first part of the the loop condition \pythonil{a != 0} become \pythonil{False} and the loop terminates.

At this point, \pythonil{digits == [11, 1, 8, 7, 5]}.
This is also right, because $\frac{179}{16}=11.1875$.

Notice that there are two conditions which can make the loop stop:
It stops if we can represent the fraction completely and exhaustively as decimal string, which was the case in our example.
It also stop if we reach the maximum number of fractional digits, i.e., if \pythonil{len(digits)} exceeds \pythonil{max_frac}.

For example, if I want to represent~$\frac{10006}{10000}=1.0006$ with only \emph{3} fractional digits.
After the loop, the list \pythonil{digits} would be \pythonil{[1, 0, 0, 0]}.
At this stage, we would have \pythonil{a = 60000} and \pythonil{b = 10000}.
The 6 at the end of the \pgls{numerator} is a bit annoying:
If we represent this fraction with three digits, it should be~1.001, not the~1.000 corresponding to our \pythonil{digits} list.
All we need to do to fix this is to check whether the next digit that we would not append to \pythonil{digits} would be greater or equal to~5.
If so, we increment the last digit by~1.\footnote{This is an error, as we will later see.}
To introduce this rounding behavior, we insert an \pythonil{if (a // b) >= 5} which does \pythonil{digits[-1] += 1} if its condition is met.

We now have a representation of the fraction as a list of decimals.
All we need to do is to convert these to a string and return them to the user.

First, we check if we need to insert a decimal dot~(\inQuotes{.}).
If we only have a single digit, then our fraction is an integer number and we can return it as such.
Thus, \pythonil{if len(digits) <= 1}, we convert the single digit to a string (after re-inserting the sign).

Otherwise, we need to have \inQuotes{.} after the first number in \pythonil{digits}.
We can use \pythonil{digits.insert(1, ".")} to place it there\pythonIdx{list!insert}.
In our original example of~$\frac{-179}{16}$, we first had \pythonil{digits == [11, 1, 8, 7, 5]}.
After this step, we get \pythonil{digits == [11, ".", 1, 8, 7, 5]}.

If the fraction was \pythonil{negative}, we place a minus sign before the string, via \pythonil{digits.insert(0, "-")}\pythonIdx{list!insert}.
In our example, this means that we get \pythonil{digits == ["-", 11, ".", 1, 8, 7, 5]}.

All what remains is translate all the integers to strings and to concatenate the result.
A single line of code takes care of that:~\pythonil{"".join(map(str, digits))}.
\pythonilIdx{map} returns a generator that applies the \pythonilIdx{str} function to all the elements in \pythonil{digits}.
\pythonilIdx{str} applied to a string just returns the string itself.
Applied to an integer, it converts it to a string.

The method \pythonil{join} of a string concatenates all elements of the sequence it receives as parameter and places the string itself as separator.
For example, \pythonil{"X".join(["a", "b", "c"])} would yield~\pythonil{"aXbXc"}.
We use the empty string for joining, so for our example, we finally return~\pythonil{-11.1875}.

After finishing the implementation of \pythonil{decimal_str}, what remains to do is to test it.
We do this by adding several standard and corner cases.
We first test that integer numbers are correctly represented.
It is clear that \pythonil{Fraction(124, 2).decimal_str()} should yield~\pythonil{"62"}.
Then we check a simple fraction that can exactly be translated:~\pythonil{Fraction(1, 2).decimal_str()} should result in~\pythonil{0.5}.

\gitOutputTool{\programmingWithPythonCodeRepo}{.}{scripts/pytest_doctest.sh 09_dunder fraction_decimal_str_err.py}{dunder:fraction_decimal_str_err:doctest}{%
The output of \pytest\ executing the \pglspl{doctest} for our \pythonil{Fraction} class with the \pythonil{decimal_str} method from \cref{lst:dunder:fraction_decimal_str_err:part_6}: It fails!}

As fraction that cannot be exactly written down as finite decimal string, we choose~$\frac{1}{3}$.
$\frac{1}{3}$ to ten digits should yield~\pythonil{"0.3333333333"}.
As example for negative fractions and also as an example for fractions with multiple leading zeros, we use~$\frac{-101001}{100000000}$.
This should give us~\pythonil{"-0.00101001"}.

As test for rounding off the last digit, we expect that \pythonil{Fraction(1235, 1000).decimal_str(2)} should yield~\pythonil{1.24}.
This number would have three fractional digits, but we only want two.
Since the third digit would be a~5, the rounding should should occur.
Instead of \pythonil{"1.235"} or \pythonil{"1.23"}, we would expect to see~\pythonil{"1.24"}.
\pythonil{Fraction(99995, 100000).decimal_str(5)}, i.e., 0.99995 rounded to five decimal digits, should yield~\pythonil{"0.99995"}.

Computing \pythonil{Fraction(91995, 100000).decimal_str(3)} means rounding 0.91995 to three decimals.
The last digit, a 5, would be cut off.
This means that we need to round-up, which would make the second-to-last 9 to also be rounded up, causing the next 9 to toggle as well.
The 1 would then be rounded up to a 2 and we should get~\pythonil{"0.92"}.
A similar thing should happen when we evaluate \pythonil{Fraction(99995, 100000).decimal_str(4)}:
Rounding 0.9995 to four digits will round-up the 5, which will cause all the 9s to toggle, finally resulting in a~\pythonil{"1"}.

In \cref{exec:dunder:fraction_decimal_str_err:doctest}, we find the results of the \pglspl{doctest} ran with \pytest.
Interestingly, they fail!
The output tells us that \pythonil{Fraction(91995, 100000).decimal_str(3)} does not yield the expected~\pythonil{"0.92"}.
Instead, we get \pythonil{"0.9110"}.

\begin{figure}%
\centering%
%
\subfloat[][%
We open a contact menu by right-clicking into out function. %
We left-click on \menu{Run \inSQuotes{Doctest decimal\_str}}.%
\label{fig:dunder:doctests1}%
]{\tightbox{\includegraphics[width=0.48\linewidth]{\currentDir/doctests1}}}%
%
\strut\hfill\strut%
%
\subfloat[][%
The \pglspl{doctest} are run, and in the window at the bottom-left, we see the failing tests.%
\label{fig:dunder:doctests2}%
]{\tightbox{\includegraphics[width=0.48\linewidth]{\currentDir/doctests2}}}%
%
\\[10pt]%
%
\subfloat[][%
Left-clicking on the first failed test in the small window shows us the test output in bottom-centered window.%
\label{fig:dunder:doctests3}%
]{\tightbox{\includegraphics[width=0.48\linewidth]{\currentDir/doctests3}}}%
%
\strut\hfill\strut%
%
\subfloat[][%
Left-clicking on the second failed test in the small window shows us the test output in bottom-centered window.%
\label{fig:dunder:doctests4}%
]{\tightbox{\includegraphics[width=0.48\linewidth]{\currentDir/doctests4}}}%%
%
\caption{Running \pglspl{doctest} in \pycharm.}%
\label{fig:dunder:doctests}%
\end{figure}%

We want to investigate this very strange error.
First, let us repeat the unit tests by also executing them inside \pycharm\ in \cref{fig:dunder:doctests}.
We open our source file and scroll to our function \pythonil{decimal_str}.
With a right mouse click, a context menu is opened.
Here, we then left-click on \menu{Run \inSQuotes{Doctest decimal\_str}}~(\cref{fig:dunder:doctests1}).

This executes \emph{all} the \pglspl{doctest}.
In the small window at the bottom-left, we can see the \emph{failing} tests~(\cref{fig:dunder:doctests2}).
We can click on these failed tests to get more information.
A left-click on the first failed test in this window in the bottom-left will then display the output of that text in the bottom-centered window~(\cref{fig:dunder:doctests3}).
This is the same information we already saw in \cref{exec:dunder:fraction_decimal_str_err:doctest}.
What we did not see in that output is that actually \emph{two} \pglspl{doctest} failed.
A left-click on the second failed test in~\cref{fig:dunder:doctests3} tells us that \pythonil{Fraction(99995, 100000).decimal_str(4)} did not yield the expected~\pythonil{"1"}.
Instead, it produced~\pythonil{"0.99910"}.

While you might have guessed the problem when reading our code for \pythonil{decimal_str}, let us here assume that we are clueless why these tests fail.
The question arises:
What can we do?

If we want to find where things go wrong, it would be very useful if we could somehow execute our program step-by-step.
When I explained how \pythonil{decimal_str} works, I used~$\frac{-179}{16}$ as an example and explained what the program would do.
Would it not be nice if we could actually step-by-step execute the program for the test and see what it \emph{actually} does?
Luckily, we can do that!
With a tool called \debugger\ which ships with \python\ and \pycharm.%
%
\usefulTool{debugger}{%
A \debugger\ is a tool that ships with many programming languages and \pglspl{IDE}. %
It allows you to execute a program step-by-step while observing the current values of variables. %
This way, you can find errors in the code more easily~\cite{W2024PME,A2002D,R2007PPBPDTAM}.%
}%
%
\begin{figure}%
\centering%
%
\subfloat[][%
We open our source code file in \pycharm\ and locate our function \pythonil{decimal_str}.%
\label{fig:dunder:debug01}%
]{\tightbox{\includegraphics[width=0.48\linewidth]{\currentDir/debug01}}}%
%
\strut\hfill\strut%
%
\subfloat[][%
We place a \pgls{breakpoint} at the first line of our function by right-clicking on the line number. %
This is denoted by the red ball over the line number. %
Later, the program execution will pause at this location.%
\label{fig:dunder:debug02}%
]{\tightbox{\includegraphics[width=0.48\linewidth]{\currentDir/debug02}}}%
%
\\[10pt]%
%
\subfloat[][%
We open the context menu by right-clicking into the \pgls{doctest} and click \menu{Debug \inSQuotes{Doctest decimal\_str}}.%
\label{fig:dunder:debug03}%
]{\tightbox{\includegraphics[width=0.48\linewidth]{\currentDir/debug03}}}%
%
\strut\hfill\strut%
%
\subfloat[][%
The execution of the \pglspl{doctest} begins, but is immediately paused the first time the \pgls{breakpoint} is reached. %
This line is now marked with blue color, but not yet executed.%
\label{fig:dunder:debug04}%
]{\tightbox{\includegraphics[width=0.48\linewidth]{\currentDir/debug04}}}%
%
\\[10pt]%
%
\subfloat[][%
We drag the \menu{Debug} register up from the bottom of our \pycharm\ window. %
We find the new register \menu{Threads \& Variables}, where we can see the value of all local variables at the current point in execution.%
\label{fig:dunder:debug05}%
]{\tightbox{\includegraphics[width=0.48\linewidth]{\currentDir/debug05}}}%
%
\strut\hfill\strut%
%
\subfloat[][%
Clicking on the variable \pythonil{self} reveals that we are in the first test case, where \pythonil{Fraction(124, 2)} is tested, which was normalized to \pythonil{Fraction(62, 1)} by the initializer~\pythonil{\_\_init\_\_}.%
\label{fig:dunder:debug06}%
]{\tightbox{\includegraphics[width=0.48\linewidth]{\currentDir/debug06}}}%
%
\caption{Using the \debugger\ in \pycharm.}%
\label{fig:dunder:debugA}%
\end{figure}%
%
In \pycharm, we can apply the \debugger\ to a complete program, but also to \pglspl{doctest}.
This is what we will do in \cref{fig:dunder:debugA}.
First, we again open our program code in \pycharm\ and locate our function \pythonil{decimal_str}~(\cref{fig:dunder:debug01}).

On the left side of our code file, there is a column with the line numbers.
We can left-click on a line to place a \pgls{breakpoint} there.
A \pgls{breakpoint} is a mark in the \pgls{IDE} at which we later want the program execution to pause.
We want our program to pause right at the beginning of \pythonil{decimal_str}, so be place the \pgls{breakpoint} there~(\cref{fig:dunder:debug02}).
The \pgls{breakpoint} is shown as a red ball over the line number.

In order to begin the debugging process, we again open the context menu by right-clicking into the \pgls{doctest}.
This time, instead of \emph{running} the \pgls{doctest}, we click \menu{Debug \inSQuotes{Doctest decimal\_str}}~(\cref{fig:dunder:debug03}).
The \pglspl{doctest} will now be executed, but instead of running them completely, the \pgls{debugger} kicks in:
The execution is paused at exactly our \pgls{breakpoint}.
This line of code is \emph{not yet executed}, but marked in blue~(\cref{fig:dunder:debug04}).

Before we continue, we look at the bottom of our \pycharm\ window.
There is a row with a \menu{Debug} register.
We can right-click the top of this row and drag it upwards.
Now we get a division of our window that contains the debug information.
Most importantly, in the register \menu{Threads \& Variables}, we can see the values of all local variables at the current point in execution~(\cref{fig:dunder:debug05}).

We see that \pythonil{max_frac} has the value \pythonil{100}.
When clicking on the variable \pythonil{self}, we see that the \pgls{numerator}~\pythonil{a} of the current fraction has value~\pythonil{62}, while the \pgls{denominator}~\pythonil{b} is~\pythonil{1}.
This is exactly what we expect:
Our first test case was \pythonil{Fraction(124, 2).decimal_str()}, so the normalized fraction is indeed~$\frac{62}{1}$.

\begin{figure}%
\ContinuedFloat%
\centering%
%
\subfloat[][%
The first \pgls{doctest} case~$\frac{124}{2}$ is uninteresting, so we continue the program execution by clicking \pycharmDebuggerResume\ or hitting \keys{F9}.%
\label{fig:dunder:debug07}%
]{\tightbox{\includegraphics[width=0.48\linewidth]{\currentDir/debug07}}}%
%
\strut\hfill\strut%
%
\subfloat[][%
The second \pgls{doctest} case~$\frac{1}{2}$ is also uninteresting. %
We continue the program execution by clicking \pycharmDebuggerResume.%
\label{fig:dunder:debug08}%
]{\tightbox{\includegraphics[width=0.48\linewidth]{\currentDir/debug08}}}%
%
\\[10pt]%
%
\subfloat[][%
The third \pgls{doctest} case, where the fraction is~$\frac{1}{3}$ and \pythonil{max_frac} is~\pythonil{10}. %
We again skip over it by pressing~\keys{F9}.%
\label{fig:dunder:debug09}%
]{\tightbox{\includegraphics[width=0.48\linewidth]{\currentDir/debug09}}}%
%
\strut\hfill\strut%
%
\subfloat[][%
The fourth \pgls{doctest} case~$\frac{-101001}{100000000}$ can be skipped as well.%
\label{fig:dunder:debug10}%
]{\tightbox{\includegraphics[width=0.48\linewidth]{\currentDir/debug10}}}%
%
\\[10pt]%
%
\subfloat[][%
The test case~$\frac{1235}{1000}$, normalized to~$\frac{247}{200}$, also was successful and can be skipped by pressing~\pycharmDebuggerResume.%
\label{fig:dunder:debug11}%
]{\tightbox{\includegraphics[width=0.48\linewidth]{\currentDir/debug11}}}%
%
\strut\hfill\strut%
%
\subfloat[][%
The last one of the uninteresting \pgls{doctest} cases:~\pythonil{Fraction(99995, 100000)}. %
We again press~\keys{F9}.%
\label{fig:dunder:debug12}%
]{\tightbox{\includegraphics[width=0.48\linewidth]{\currentDir/debug12}}}%
%
\caption{Using the \debugger\ in \pycharm.}%
\label{fig:dunder:debugB}%
\end{figure}%

This test case is already successful, so we are not interested in it.
Among the symbols in \menu{Debug} register, we click \pycharmDebuggerResume, which will let the program continue its execution~(\cref{fig:dunder:debug07}).
Alternatively, we can hit \keys{F9}, which has the same effect.
The execution of the \pglspl{doctest} is resumed, but again pauses at our \pgls{breakpoint}~(\cref{fig:dunder:debug08}).
This time, we can see that we have arrived at the beginning of the second \pgls{doctest} case with \pythonil{Fraction(1, 2)}.
We again continue by clicking \pycharmDebuggerResume\ or pressing~\keys{F9}.
This takes us to the beginning of the third \pgls{doctest} case, where the fraction is~$\frac{1}{3}$ and \pythonil{max_frac} is~\pythonil{10}~(\cref{fig:dunder:debug09}).
We can skip it as well by pressing~\keys{F9}.
The next time we reach the \pgls{breakpoint} is for the fourth \pgls{doctest} case, $\frac{-101001}{100000000}$~(\cref{fig:dunder:debug10}), which we skip, too.
When the debugger arrives at the fifth test case, \pythonil{Fraction(1235, 1000)}, we find that this fraction has been normalized correctly to~$\frac{247}{200}$.
Nonetheless, we can skip this test case via \keys{F9}, too, because we know that it will succeed~(\cref{fig:dunder:debug11}).
This takes us to the last successful \pgls{doctest} case, \pythonil{Fraction(99995, 100000)}, which corresponds to~$\frac{19999}{20000}$ in \cref{fig:dunder:debug12}.
After skipping it by pressing~\pycharmDebuggerResume, we will finally arrive at the cases that did fail and which we hence want to investigate step-by-step.%
\clearpage%
%
\begin{figure}%
\ContinuedFloat%
\centering%
%
\subfloat[][%
We arrive at the beginning of the failing \pgls{doctest} case \pythonil{Fraction(91995, 100000).decimal_str(3)}. %
The \pythonil{max_frac} parameter has value~\pythonil{3}, \pythonil{self.a} is \pythonil{18399} and \pythonil{self.b} is \pythonil{20000}, because the fraction was normalized in \pythonil{\_\_init\_\_}.%
\label{fig:dunder:debug13}%
]{\tightbox{\includegraphics[width=0.48\linewidth]{\currentDir/debug13}}}%
%
\strut\hfill\strut%
%
\subfloat[][%
We now execute the first line of the \pythonil{decimal_str} function where the \pgls{debugger} has paused. %
This is done by either pressing the \pycharmDebuggerStepOver~button or by hitting~\keys{F8}.%
\label{fig:dunder:debug14}%
]{\tightbox{\includegraphics[width=0.48\linewidth]{\currentDir/debug14}}}%
%
\\[10pt]%
%
\subfloat[][%
The execution of the assignment \pythonil{a = self.a} creates a new local variable~\pythonil{a} with value~\pythonil{18399}. %
We press \keys{F8} to continue the execution.%
\label{fig:dunder:debug15}%
]{\tightbox{\includegraphics[width=0.48\linewidth]{\currentDir/debug15}}}%
%
\strut\hfill\strut%
%
\subfloat[][%
The condition for the \pythonil{if} is not met, so the execution jumps over its body and the next line after the \pythonil{if} is marked. %
We execute it by pressing~\pythonil{F8}.%
\label{fig:dunder:debug16}%
]{\tightbox{\includegraphics[width=0.48\linewidth]{\currentDir/debug16}}}%
%
\\[10pt]%
%
\subfloat[][%
The new local variable~\pythonil{negative} with value~\pythonil{False} appears. %
The next line of code is marked and we execute it by pressing~\pycharmDebuggerStepOver.%
\label{fig:dunder:debug17}%
]{\tightbox{\includegraphics[width=0.48\linewidth]{\currentDir/debug17}}}%
%
\strut\hfill\strut%
%
\subfloat[][%
\pythonil{a = abs(a)} has no effect, since \pythonil{a} is already positive.
We press \keys{F8} to continue.%
\label{fig:dunder:debug18}%
]{\tightbox{\includegraphics[width=0.48\linewidth]{\currentDir/debug18}}}%
%
%
\caption{Using the \debugger\ in \pycharm.}%
\label{fig:dunder:debugC}%
\end{figure}%
%
\begin{sloppypar}%
\Cref{fig:dunder:debug13} shows that we now arrived at the beginning of the failing \pgls{doctest} case \pythonil{Fraction(91995, 100000).decimal_str(3)}.
The fraction~$\frac{91995}{100000}$ got normalized to~$\frac{18399}{20000}$ in the initializer~\pythonil{\_\_init\_\_}.
The parameter \pythonil{max_frac} of \pythonil{decimal_str} has the value~\pythonil{3}, as we can see in the \menu{Threads \& Variables} window.
We now want to execute the \pythonil{decimal_str} method step-by-step.
Right now, the \pgls{debugger} has paused the execution right at the very first line of this function.
This line has not yet been executed.%
\end{sloppypar}%
%
In \cref{fig:dunder:debug14}, we execute this line of code, either by pressing the \pycharmDebuggerStepOver~button or by hitting~\keys{F8}.
We can see in \cref{fig:dunder:debug15} that now a new variable has appeared in the \menu{Threads \& Variables} window.
Since we executed \pythonil{a = self.a}, the local variable~\pythonil{a} now exists and has value~\pythonil{18399}.
Now, the next line of code that can be executed is marked with blue color.

By pressing \keys{F8}, the \pythonil{if a == 0:} is executed.
Since \pythonil{a == 0} is not \pythonil{True}, the body of the \pythonil{if} is not executed.
The program jumps right over it.
The next line after the \pythonil{if} is marked~\cref{fig:dunder:debug16}.
We execute it by pressing~\keys{F8}.

The local variable \pythonil{negative} is created.
Since \pythonil{a < 0} is \pythonil{False}, \pythonil{negative} is \pythonil{False}, too.
The next line of code is marked and we press~\pycharmDebuggerStepOver\ to execute it~(\cref{fig:dunder:debug17}).

\pythonil{a = abs(a)} has no effect, since \pythonil{a} is already positive.
We press \keys{F8} to continue~(\cref{fig:dunder:debug18}).

\begin{figure}%
\ContinuedFloat%
\centering%
%
\subfloat[][%
After executing \pythonil{b = self.b}, the new local variable \pythonil{b} with value \pythonil{20000} comes into existence. %
We continue debugging by pressing~\keys{F8}.%
\label{fig:dunder:debug19}%
]{\tightbox{\includegraphics[width=0.48\linewidth]{\currentDir/debug19}}}%
%
\strut\hfill\strut%
%
\subfloat[][%
The empty list \pythonil{digits} has been created. %
By pressing~\keys{F8}, the executing \pythonil{while} loop will begin by checking its condition.%
\label{fig:dunder:debug20}%
]{\tightbox{\includegraphics[width=0.48\linewidth]{\currentDir/debug20}}}%
%
\\[10pt]%
%
\subfloat[][%
The condition of the \pythonil{while} loop is met. %
The first line of the loop's body is marked. %
We press~\pycharmDebuggerStepOver\ to execute it.%
\label{fig:dunder:debug21}%
]{\tightbox{\includegraphics[width=0.48\linewidth]{\currentDir/debug21}}}%
%
\strut\hfill\strut%
%
\subfloat[][%
Using the \debugger\ in \pycharm.%
\label{fig:dunder:debug22}%
]{\tightbox{\includegraphics[width=0.48\linewidth]{\currentDir/debug22}}}%
%
\\[10pt]%
%
\subfloat[][%
Using the \debugger\ in \pycharm.%
\label{fig:dunder:debug23}%
]{\tightbox{\includegraphics[width=0.48\linewidth]{\currentDir/debug23}}}%
%
\strut\hfill\strut%
%
\subfloat[][%
Using the \debugger\ in \pycharm.%
\label{fig:dunder:debug24}%
]{\tightbox{\includegraphics[width=0.48\linewidth]{\currentDir/debug24}}}%
%
\caption{Using the \debugger\ in \pycharm.}%
\label{fig:dunder:debugD}%
\end{figure}

This executes \pythonil{b = self.b}.
Thus, the new local variable \pythonil{b} with value \pythonil{20000} is created in~\cref{fig:dunder:debug19}.
We are now at the last line of \inQuotes{trivial setup} of our \pythonil{decimal_str} method, the creation of the list~\pythonil{digits}.
We continue debugging by pressing~\keys{F8}.

The new variable~\pythonil{digits} has indeed appeared in~\cref{fig:dunder:debug20}.
It is an empty list~\pythonil{[]}.
We arrived at the beginning the \pythonil{while} loop.
We press \keys{F8}, which will cause the condition of the loop being checked.

In \cref{fig:dunder:debug21}, we find that now the first line of the loop's body is marked.
This means that \pythonil{a != 0} and \pythonil{len(digits) <= max_frac} are both~\pythonil{True}.
And they should be, since \pythonil{a} is \pythonil{18399}, \pythonil{len(digits)} if~0, and \pythonil{max_frac} is~3.
We press~\pycharmDebuggerStepOver.

\begin{figure}%
\ContinuedFloat%
\centering%
%
\subfloat[][%
Using the \debugger\ in \pycharm.%
\label{fig:dunder:debug25}%
]{\tightbox{\includegraphics[width=0.48\linewidth]{\currentDir/debug25}}}%
%
\strut\hfill\strut%
%
\subfloat[][%
Using the \debugger\ in \pycharm.%
\label{fig:dunder:debug26}%
]{\tightbox{\includegraphics[width=0.48\linewidth]{\currentDir/debug26}}}%
%
\\[10pt]%
%
\subfloat[][%
Using the \debugger\ in \pycharm.%
\label{fig:dunder:debug27}%
]{\tightbox{\includegraphics[width=0.48\linewidth]{\currentDir/debug27}}}%
%
\strut\hfill\strut%
%
\subfloat[][%
Using the \debugger\ in \pycharm.%
\label{fig:dunder:debug28}%
]{\tightbox{\includegraphics[width=0.48\linewidth]{\currentDir/debug28}}}%
%
\\[10pt]%
%
\subfloat[][%
Using the \debugger\ in \pycharm.%
\label{fig:dunder:debug29}%
]{\tightbox{\includegraphics[width=0.48\linewidth]{\currentDir/debug29}}}%
%
\strut\hfill\strut%
%
\subfloat[][%
Using the \debugger\ in \pycharm.%
\label{fig:dunder:debug30}%
]{\tightbox{\includegraphics[width=0.48\linewidth]{\currentDir/debug30}}}%
%
%
\caption{Using the \debugger\ in \pycharm.}%
\label{fig:dunder:debugE}%
\end{figure}%
%
%
\begin{figure}%
\ContinuedFloat%
\centering%
%
\subfloat[][%
Using the \debugger\ in \pycharm.%
\label{fig:dunder:debug31}%
]{\tightbox{\includegraphics[width=0.48\linewidth]{\currentDir/debug31}}}%
%
\strut\hfill\strut%
%
\subfloat[][%
Using the \debugger\ in \pycharm.%
\label{fig:dunder:debug32}%
]{\tightbox{\includegraphics[width=0.48\linewidth]{\currentDir/debug32}}}%
%
\\[10pt]%
%
\subfloat[][%
Using the \debugger\ in \pycharm.%
\label{fig:dunder:debug33}%
]{\tightbox{\includegraphics[width=0.48\linewidth]{\currentDir/debug33}}}%
%
\strut\hfill\strut%
%
\subfloat[][%
Using the \debugger\ in \pycharm.%
\label{fig:dunder:debug34}%
]{\tightbox{\includegraphics[width=0.48\linewidth]{\currentDir/debug34}}}%
%
\\[10pt]%
%
\subfloat[][%
Using the \debugger\ in \pycharm.%
\label{fig:dunder:debug35}%
]{\tightbox{\includegraphics[width=0.8\linewidth]{\currentDir/debug35}}}%
%
\caption{Using the \debugger\ in \pycharm.}%
\label{fig:dunder:debugF}%
\end{figure}%
%
\gitPython{\programmingWithPythonCodeRepo}{09_dunder/fraction.py}{--args format --labels part_6}{dunder:fraction:part_6}{%
The repaired Part~6 of the \pythonil{Fraction} class: A correct \pythonil{decimal_str} method.}%
%
\gitPython{\programmingWithPythonCodeRepo}{09_dunder/fraction_sqrt.py}{--args format}{dunder:fraction_sqrt}{%
Using the \pythonil{Fraction} class to compute square roots.}%
%
\gitOutputTool{\programmingWithPythonCodeRepo}{.}{scripts/pytest_doctest.sh 09_dunder fraction_sqrt.py}{dunder:fraction_sqrt:doctest}{%
The (successful) output of \pytest\ executing the \pglspl{doctest} for our \pythonil{sqrt} function from~\cref{lst:dunder:fraction_sqrt} working on instances of the \pythonil{Fraction} class.}%
%
\FloatBarrier%
\endhsection%
%
\endhsection%
